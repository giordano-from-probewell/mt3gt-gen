#include "app_cpu1.h"
#include "my_time.h"
#include "cla1_standard_shared.h"

#include "SFO_V8.h"

#include "ada4254.h"
#include "my_i2c.h"
#include "si5351c.h"
#include "spline.h"


#include "ipc_simple.h"
#include "frequency.h"
#include "led_pulse_pwm.h"
#include "zero_phase_timer.h"



#define TO_CPU1 0
#define TO_CPU2 1
#define CONNECT_TO_CLA1 0
#define CONNECT_TO_DMA 1
#define CONNECT_TO_CLA2 2
#define ENABLE 1
#define DISABLE 0

#define CPU1_CLA1(x)                        \
        EALLOW;                             \
        DevCfgRegs.DC1.bit.CPU1_CLA1 = x;   \
        EDIS
#define CPU2_CLA1(x)                        \
        EALLOW;                             \
        DevCfgRegs.DC1.bit.CPU2_CLA1 = x;   \
        EDIS
#define WAITSTEP asm(" RPT #255 || NOP")







void _app_gpio_init(void);

void _init_phase(phase_t * phase, phase_desc_t desc, analog_input_t * voltge_input, analog_input_t * current_input  );


void _cla1_init(void);
void _cla1_interruption_config(void);
void _cla1_interruption_config(void);

__interrupt void mcbspb_rx_isr_adc(void);
__interrupt void access_violation(void);
__interrupt void dmaADSchannels(void);
__interrupt void xint1_isr(void);

void ledtest_begin(const ledtest_cfg_t *cfg);
void led_zc_isr(void);

void ADS1278_init(void);
void ADS1278_sync(void);
void ADS1278_initControls(void);
void configDMA_ADS1278(void);
void McBSP_config_funcs(void);
void McBSP_config_bitmap(void);
void McBSPB_pin_config(void);



__interrupt void Cla1Task1();
__interrupt void Cla1Task2();
__interrupt void Cla1Task3();
__interrupt void Cla1Task4();
__interrupt void Cla1Task5();
__interrupt void Cla1Task6();
__interrupt void Cla1Task7();
__interrupt void Cla1Task8();
__interrupt void cla1Isr1();
__interrupt void cla1Isr2();
__interrupt void cla1Isr3();
__interrupt void cla1Isr4();
__interrupt void cla1Isr5();
__interrupt void cla1Isr6();
__interrupt void cla1Isr7();
__interrupt void cla1Isr8();


volatile uint32_t fetchAddress;



//float32_t sinus512[512] = {0.012272, 0.024541228522912, 0.036807222941359, 0.049067674327418, 0.061320736302209, 0.073564563599667, 0.085797312344440, 0.098017140329561, 0.110222207293883, 0.122410675199216, 0.134580708507126, 0.146730474455362, 0.158858143333861, 0.170961888760301, 0.183039887955141, 0.195090322016128, 0.207111376192219, 0.219101240156870, 0.231058108280671, 0.242980179903264, 0.254865659604515, 0.266712757474898, 0.278519689385053, 0.290284677254462, 0.302005949319228, 0.313681740398892, 0.325310292162263, 0.336889853392220, 0.348418680249435, 0.359895036534988, 0.371317193951838, 0.382683432365090, 0.393992040061048, 0.405241314004990, 0.416429560097637, 0.427555093430282, 0.438616238538528, 0.449611329654607, 0.460538710958240, 0.471396736825998, 0.482183772079123, 0.492898192229784, 0.503538383725718, 0.514102744193222, 0.524589682678469, 0.534997619887097, 0.545324988422046, 0.555570233019602, 0.565731810783613, 0.575808191417845, 0.585797857456439, 0.595699304492433, 0.605511041404326, 0.615231590580627, 0.624859488142386, 0.634393284163645, 0.643831542889791, 0.653172842953777, 0.662415777590172, 0.671558954847018, 0.680600997795453, 0.689540544737067, 0.698376249408973, 0.707106781186547, 0.715730825283819, 0.724247082951467, 0.732654271672413, 0.740951125354959, 0.749136394523459, 0.757208846506484, 0.765167265622459, 0.773010453362737, 0.780737228572094, 0.788346427626606, 0.795836904608883, 0.803207531480645, 0.810457198252595, 0.817584813151584, 0.824589302785025, 0.831469612302545, 0.838224705554838, 0.844853565249707, 0.851355193105265, 0.857728610000272, 0.863972856121587, 0.870086991108711, 0.876070094195407, 0.881921264348355, 0.887639620402854, 0.893224301195515, 0.898674465693954, 0.903989293123443, 0.909167983090522, 0.914209755703531, 0.919113851690058, 0.923879532511287, 0.928506080473215, 0.932992798834739, 0.937339011912575, 0.941544065183021, 0.945607325380521, 0.949528180593037, 0.953306040354194, 0.956940335732209, 0.960430519415566, 0.963776065795440, 0.966976471044852, 0.970031253194544, 0.972939952205560, 0.975702130038529, 0.978317370719628, 0.980785280403230, 0.983105487431216, 0.985277642388941, 0.987301418157858, 0.989176509964781, 0.990902635427780, 0.992479534598710, 0.993906970002356, 0.995184726672197, 0.996312612182778, 0.997290456678690, 0.998118112900149, 0.998795456205172, 0.999322384588350, 0.999698818696204, 0.999924701839145, 1.000000000000000, 0.999924701839145, 0.999698818696204, 0.999322384588350, 0.998795456205172, 0.998118112900149, 0.997290456678690, 0.996312612182778, 0.995184726672197, 0.993906970002356, 0.992479534598710, 0.990902635427780, 0.989176509964781, 0.987301418157858, 0.985277642388941, 0.983105487431216, 0.980785280403230, 0.978317370719628, 0.975702130038529, 0.972939952205560, 0.970031253194544, 0.966976471044852, 0.963776065795440, 0.960430519415566, 0.956940335732209, 0.953306040354194, 0.949528180593037, 0.945607325380521, 0.941544065183021, 0.937339011912575, 0.932992798834739, 0.928506080473216, 0.923879532511287, 0.919113851690058, 0.914209755703531, 0.909167983090522, 0.903989293123443, 0.898674465693954, 0.893224301195515, 0.887639620402854, 0.881921264348355, 0.876070094195407, 0.870086991108711, 0.863972856121587, 0.857728610000272, 0.851355193105265, 0.844853565249707, 0.838224705554838, 0.831469612302545, 0.824589302785025, 0.817584813151584, 0.810457198252595, 0.803207531480645, 0.795836904608884, 0.788346427626606, 0.780737228572095, 0.773010453362737, 0.765167265622459, 0.757208846506485, 0.749136394523459, 0.740951125354959, 0.732654271672413, 0.724247082951467, 0.715730825283819, 0.707106781186548, 0.698376249408973, 0.689540544737067, 0.680600997795453, 0.671558954847019, 0.662415777590172, 0.653172842953777, 0.643831542889791, 0.634393284163645, 0.624859488142386, 0.615231590580627, 0.605511041404326, 0.595699304492433, 0.585797857456439, 0.575808191417845, 0.565731810783613, 0.555570233019602, 0.545324988422046, 0.534997619887097, 0.524589682678469, 0.514102744193222, 0.503538383725718, 0.492898192229784, 0.482183772079123, 0.471396736825998, 0.460538710958240, 0.449611329654607, 0.438616238538528, 0.427555093430282, 0.416429560097637, 0.405241314004990, 0.393992040061048, 0.382683432365090, 0.371317193951838, 0.359895036534988, 0.348418680249435, 0.336889853392220, 0.325310292162263, 0.313681740398891, 0.302005949319228, 0.290284677254462, 0.278519689385053, 0.266712757474898, 0.254865659604515, 0.242980179903264, 0.231058108280671, 0.219101240156870, 0.207111376192219, 0.195090322016129, 0.183039887955141, 0.170961888760301, 0.158858143333861, 0.146730474455362, 0.134580708507126, 0.122410675199216, 0.110222207293883, 0.098017140329561, 0.085797312344440, 0.073564563599668, 0.061320736302208, 0.049067674327418, 0.036807222941359, 0.024541228522912, 0.012271538285720, 0.000000000000000, -0.012271538285720, -0.024541228522912, -0.036807222941359, -0.049067674327418, -0.061320736302208, -0.073564563599667, -0.085797312344440, -0.098017140329561, -0.110222207293883, -0.122410675199216, -0.134580708507126, -0.146730474455362, -0.158858143333861, -0.170961888760301, -0.183039887955141, -0.195090322016128, -0.207111376192219, -0.219101240156870, -0.231058108280671, -0.242980179903264, -0.254865659604514, -0.266712757474898, -0.278519689385053, -0.290284677254462, -0.302005949319228, -0.313681740398891, -0.325310292162263, -0.336889853392220, -0.348418680249435, -0.359895036534988, -0.371317193951837, -0.382683432365090, -0.393992040061048, -0.405241314004990, -0.416429560097637, -0.427555093430282, -0.438616238538527, -0.449611329654607, -0.460538710958240, -0.471396736825998, -0.482183772079123, -0.492898192229784, -0.503538383725717, -0.514102744193222, -0.524589682678469, -0.534997619887097, -0.545324988422046, -0.555570233019602, -0.565731810783613, -0.575808191417845, -0.585797857456439, -0.595699304492433, -0.605511041404325, -0.615231590580627, -0.624859488142386, -0.634393284163645, -0.643831542889791, -0.653172842953777, -0.662415777590172, -0.671558954847018, -0.680600997795453, -0.689540544737067, -0.698376249408973, -0.707106781186547, -0.715730825283818, -0.724247082951467, -0.732654271672413, -0.740951125354959, -0.749136394523459, -0.757208846506484, -0.765167265622459, -0.773010453362737, -0.780737228572094, -0.788346427626606, -0.795836904608883, -0.803207531480645, -0.810457198252595, -0.817584813151584, -0.824589302785025, -0.831469612302545, -0.838224705554838, -0.844853565249707, -0.851355193105265, -0.857728610000272, -0.863972856121586, -0.870086991108711, -0.876070094195407, -0.881921264348355, -0.887639620402854, -0.893224301195515, -0.898674465693954, -0.903989293123443, -0.909167983090522, -0.914209755703530, -0.919113851690058, -0.923879532511287, -0.928506080473215, -0.932992798834739, -0.937339011912575, -0.941544065183021, -0.945607325380521, -0.949528180593037, -0.953306040354194, -0.956940335732209, -0.960430519415566, -0.963776065795440, -0.966976471044852, -0.970031253194544, -0.972939952205560, -0.975702130038528, -0.978317370719628, -0.980785280403230, -0.983105487431216, -0.985277642388941, -0.987301418157858, -0.989176509964781, -0.990902635427780, -0.992479534598710, -0.993906970002356, -0.995184726672197, -0.996312612182778, -0.997290456678690, -0.998118112900149, -0.998795456205172, -0.999322384588349, -0.999698818696204, -0.999924701839145, -1.000000000000000, -0.999924701839145, -0.999698818696204, -0.999322384588350, -0.998795456205172, -0.998118112900149, -0.997290456678690, -0.996312612182778, -0.995184726672197, -0.993906970002356, -0.992479534598710, -0.990902635427780, -0.989176509964781, -0.987301418157858, -0.985277642388941, -0.983105487431216, -0.980785280403230, -0.978317370719628, -0.975702130038529, -0.972939952205560, -0.970031253194544, -0.966976471044852, -0.963776065795440, -0.960430519415566, -0.956940335732209, -0.953306040354194, -0.949528180593037, -0.945607325380521, -0.941544065183021, -0.937339011912575, -0.932992798834739, -0.928506080473216, -0.923879532511287, -0.919113851690058, -0.914209755703531, -0.909167983090522, -0.903989293123443, -0.898674465693954, -0.893224301195515, -0.887639620402854, -0.881921264348355, -0.876070094195407, -0.870086991108711, -0.863972856121587, -0.857728610000272, -0.851355193105265, -0.844853565249707, -0.838224705554838, -0.831469612302545, -0.824589302785025, -0.817584813151584, -0.810457198252595, -0.803207531480645, -0.795836904608884, -0.788346427626606, -0.780737228572095, -0.773010453362737, -0.765167265622459, -0.757208846506485, -0.749136394523460, -0.740951125354959, -0.732654271672413, -0.724247082951467, -0.715730825283819, -0.707106781186548, -0.698376249408973, -0.689540544737067, -0.680600997795453, -0.671558954847019, -0.662415777590172, -0.653172842953777, -0.643831542889791, -0.634393284163646, -0.624859488142386, -0.615231590580627, -0.605511041404326, -0.595699304492433, -0.585797857456439, -0.575808191417845, -0.565731810783614, -0.555570233019602, -0.545324988422047, -0.534997619887097, -0.524589682678469, -0.514102744193222, -0.503538383725718, -0.492898192229784, -0.482183772079123, -0.471396736825998, -0.460538710958240, -0.449611329654607, -0.438616238538528, -0.427555093430283, -0.416429560097637, -0.405241314004990, -0.393992040061048, -0.382683432365090, -0.371317193951838, -0.359895036534988, -0.348418680249435, -0.336889853392220, -0.325310292162263, -0.313681740398892, -0.302005949319229, -0.290284677254462, -0.278519689385054, -0.266712757474899, -0.254865659604514, -0.242980179903264, -0.231058108280671, -0.219101240156870, -0.207111376192219, -0.195090322016129, -0.183039887955141, -0.170961888760302, -0.158858143333862, -0.146730474455362, -0.134580708507126, -0.122410675199216, -0.110222207293883, -0.098017140329561, -0.085797312344440, -0.073564563599667, -0.061320736302209, -0.049067674327418, -0.036807222941359, -0.024541228522912, -0.012271538285721, -0.000000000000000};
const float32_t sinus651[651] = { 0.009651, 0.019301981920904, 0.028950725326236, 0.038596771899913, 0.048239223088843, 0.057877180674855, 0.067509746858365, 0.077136024342015, 0.086755116414252, 0.096366127032863, 0.105968160908443, 0.115560323587791, 0.125141721537235, 0.134711462225861, 0.144268654208661, 0.153812407209567, 0.163341832204388, 0.172856041503620, 0.182354148835140, 0.191835269426763, 0.201298520088660, 0.210743019295631, 0.220167887269220, 0.229572246059670, 0.238955219627702, 0.248315933926128, 0.257653516981262, 0.266967098974152, 0.276255812321604, 0.285518791757002, 0.294755174410904, 0.303964099891427, 0.313144710364388, 0.322296150633222, 0.331417568218636, 0.340508113438026, 0.349566939484627, 0.358593202506390, 0.367586061684595, 0.376544679312171, 0.385468220871733, 0.394355855113319, 0.403206754131820, 0.412020093444106, 0.420795052065827, 0.429530812587888, 0.438226561252594, 0.446881488029453, 0.455494786690634, 0.464065654886068, 0.472593294218187, 0.481076910316300, 0.489515712910590, 0.497908915905726, 0.506255737454095, 0.514555400028629, 0.522807130495235, 0.531010160184815, 0.539163724964869, 0.547267065310674, 0.555319426376041, 0.563320058063622, 0.571268215094792, 0.579163157079070, 0.587004148583085, 0.594790459199090, 0.602521363612998, 0.610196141671943, 0.617814078451373, 0.625374464321637, 0.632876595014096, 0.640319771686725, 0.647703300989211, 0.655026495127540, 0.662288671928070, 0.669489154901074, 0.676627273303757, 0.683702362202739, 0.690713762535992, 0.697660821174238, 0.704542890981785, 0.711359330876813, 0.718109505891090, 0.724792787229120, 0.731408552326721, 0.737956184909013, 0.744435075047831, 0.750844619218537, 0.757184220356242, 0.763453287911422, 0.769651237904932, 0.775777492982405, 0.781831482468030, 0.787812642417716, 0.793720415671623, 0.799554251906064, 0.805313607684768, 0.810997946509501, 0.816606738870046, 0.822139462293524, 0.827595601393068, 0.832974647915827, 0.838276100790316, 0.843499466173092, 0.848644257494751, 0.853709995505260, 0.858696208318596, 0.863602431456707, 0.868428207892773, 0.873173088093787, 0.877836630062425, 0.882418399378219, 0.886917969238029, 0.891334920495795, 0.895668841701585, 0.899919329139921, 0.904085986867389, 0.908168426749516, 0.912166268496933, 0.916079139700796, 0.919906675867474, 0.923648520452511, 0.927304324893829, 0.930873748644204, 0.934356459202988, 0.937752132147080, 0.941060451161149, 0.944281108067096, 0.947413802852767, 0.950458243699897, 0.953414147011291, 0.956281237437247, 0.959059247901202, 0.961747919624612, 0.964347002151056, 0.966856253369570, 0.969275439537199, 0.971604335300769, 0.973842723717880, 0.975990396277115, 0.978047152917466, 0.980012802046965, 0.981887160560535, 0.983670053857046, 0.985361315855577, 0.986960789010892, 0.988468324328111, 0.989883781376592, 0.991207028303009, 0.992437941843640, 0.993576407335845, 0.994622318728747, 0.995575578593114, 0.996436098130433, 0.997203797181180, 0.997878604232291, 0.998460456423820, 0.998949299554796, 0.999345088088274, 0.999647785155572, 0.999857362559710, 0.999973800778035, 0.999997088964038, 0.999927224948369, 0.999764215239031, 0.999508075020784, 0.999158828153721, 0.998716507171053, 0.998181153276071, 0.997552816338317, 0.996831554888928, 0.996017436115193, 0.995110535854288, 0.994110938586216, 0.993018737425934, 0.991834034114680, 0.990556939010498, 0.989187571077956, 0.987726057877061, 0.986172535551382, 0.984527148815367, 0.982790050940858, 0.980961403742818, 0.979041377564255, 0.977030151260356, 0.974927912181824, 0.972734856157428, 0.970451187475760, 0.968077118866204, 0.965612871479123, 0.963058674865254, 0.960414766954328, 0.957681394032905, 0.954858810721431, 0.951947279950522, 0.948947072936469, 0.945858469155974, 0.942681756320118, 0.939417230347555, 0.936065195336954, 0.932625963538664, 0.929099855325633, 0.925487199163560, 0.921788331580299, 0.918003597134513, 0.914133348383575, 0.910177945850726, 0.906137757991494, 0.902013161159367, 0.897804539570742, 0.893512285269125, 0.889136798088619, 0.884678485616675, 0.880137763156124, 0.875515053686492, 0.870810787824598, 0.866025403784439, 0.861159347336372, 0.856213071765588, 0.851187037829888, 0.846081713716762, 0.840897574999776, 0.835635104594270, 0.830294792712376, 0.824877136817352, 0.819382641577242, 0.813811818817863, 0.808165187475132, 0.802443273546722, 0.796646610043064, 0.790775736937699, 0.784831201116972, 0.778813556329098, 0.772723363132566, 0.766561188843936, 0.760327607484978, 0.754023199729211, 0.747648552847809, 0.741204260654891, 0.734690923452211, 0.728109147973235, 0.721459547326626, 0.714742740939127, 0.707959354497862, 0.701110019892053, 0.694195375154156, 0.687216064400426, 0.680172737770920, 0.673066051368929, 0.665896667199867, 0.658665253109596, 0.651372482722222, 0.644019035377341, 0.636605596066755, 0.629132855370670, 0.621601509393360, 0.614012259698327, 0.606365813242947, 0.598662882312615, 0.590904184454397, 0.583090442410182, 0.575222384049366, 0.567300742301040, 0.559326255085723, 0.551299665246619, 0.543221720480419, 0.535093173267654, 0.526914780802597, 0.518687304922731, 0.510411512037779, 0.502088173058312, 0.493718063323940, 0.485301962531081, 0.476840654660337, 0.468334927903459, 0.459785574589928, 0.451193391113145, 0.442559177856250, 0.433883739117558, 0.425167883035641, 0.416412421514045, 0.407618170145663, 0.398785948136755, 0.389916578230643, 0.381010886631066, 0.372069702925219, 0.363093860006475, 0.354084193996797, 0.345041544168852, 0.335966752867836, 0.326860665432995, 0.317724130118895, 0.308557998016392, 0.299363122973358, 0.290140361515141, 0.280890572764777, 0.271614618362962, 0.262313362387785, 0.252987671274243, 0.243638413733522, 0.234266460672083, 0.224872685110527, 0.215457962102278, 0.206023168652066, 0.196569183634230, 0.187096887710855, 0.177607163249727, 0.168100894242148, 0.158578966220584, 0.149042266176175, 0.139491682476113, 0.129928104780888, 0.120352423961410, 0.110765532016028, 0.101168321987433, 0.091561687879471, 0.081946524573865, 0.072323727746854, 0.062694193785758, 0.053058819705479, 0.043418503064937, 0.033774141883469, 0.024126634557165, 0.014476879775191, 0.004825776436067, -0.004825776436066, -0.014476879775191, -0.024126634557165, -0.033774141883468, -0.043418503064937, -0.053058819705479, -0.062694193785758, -0.072323727746854, -0.081946524573864, -0.091561687879470, -0.101168321987432, -0.110765532016028, -0.120352423961410, -0.129928104780888, -0.139491682476113, -0.149042266176174, -0.158578966220584, -0.168100894242148, -0.177607163249727, -0.187096887710854, -0.196569183634230, -0.206023168652065, -0.215457962102278, -0.224872685110527, -0.234266460672083, -0.243638413733522, -0.252987671274243, -0.262313362387786, -0.271614618362961, -0.280890572764777, -0.290140361515141, -0.299363122973358, -0.308557998016391, -0.317724130118895, -0.326860665432995, -0.335966752867835, -0.345041544168852, -0.354084193996796, -0.363093860006475, -0.372069702925219, -0.381010886631066, -0.389916578230643, -0.398785948136755, -0.407618170145662, -0.416412421514045, -0.425167883035641, -0.433883739117558, -0.442559177856250, -0.451193391113145, -0.459785574589927, -0.468334927903459, -0.476840654660337, -0.485301962531081, -0.493718063323940, -0.502088173058312, -0.510411512037778, -0.518687304922731, -0.526914780802597, -0.535093173267653, -0.543221720480419, -0.551299665246619, -0.559326255085723, -0.567300742301040, -0.575222384049366, -0.583090442410182, -0.590904184454396, -0.598662882312615, -0.606365813242947, -0.614012259698328, -0.621601509393360, -0.629132855370670, -0.636605596066755, -0.644019035377340, -0.651372482722222, -0.658665253109596, -0.665896667199867, -0.673066051368929, -0.680172737770919, -0.687216064400426, -0.694195375154156, -0.701110019892053, -0.707959354497862, -0.714742740939127, -0.721459547326626, -0.728109147973235, -0.734690923452211, -0.741204260654891, -0.747648552847809, -0.754023199729211, -0.760327607484978, -0.766561188843935, -0.772723363132566, -0.778813556329097, -0.784831201116972, -0.790775736937699, -0.796646610043064, -0.802443273546722, -0.808165187475132, -0.813811818817863, -0.819382641577242, -0.824877136817353, -0.830294792712377, -0.835635104594270, -0.840897574999776, -0.846081713716762, -0.851187037829888, -0.856213071765588, -0.861159347336372, -0.866025403784439, -0.870810787824598, -0.875515053686492, -0.880137763156124, -0.884678485616675, -0.889136798088619, -0.893512285269125, -0.897804539570742, -0.902013161159367, -0.906137757991494, -0.910177945850726, -0.914133348383575, -0.918003597134513, -0.921788331580299, -0.925487199163559, -0.929099855325633, -0.932625963538665, -0.936065195336954, -0.939417230347555, -0.942681756320118, -0.945858469155974, -0.948947072936469, -0.951947279950522, -0.954858810721431, -0.957681394032905, -0.960414766954328, -0.963058674865254, -0.965612871479123, -0.968077118866204, -0.970451187475760, -0.972734856157428, -0.974927912181824, -0.977030151260356, -0.979041377564255, -0.980961403742818, -0.982790050940858, -0.984527148815367, -0.986172535551382, -0.987726057877060, -0.989187571077955, -0.990556939010498, -0.991834034114680, -0.993018737425934, -0.994110938586216, -0.995110535854288, -0.996017436115193, -0.996831554888928, -0.997552816338317, -0.998181153276071, -0.998716507171053, -0.999158828153721, -0.999508075020784, -0.999764215239031, -0.999927224948369, -0.999997088964038, -0.999973800778035, -0.999857362559710, -0.999647785155572, -0.999345088088274, -0.998949299554796, -0.998460456423820, -0.997878604232291, -0.997203797181180, -0.996436098130433, -0.995575578593114, -0.994622318728747, -0.993576407335845, -0.992437941843640, -0.991207028303009, -0.989883781376592, -0.988468324328111, -0.986960789010892, -0.985361315855577, -0.983670053857046, -0.981887160560535, -0.980012802046965, -0.978047152917466, -0.975990396277115, -0.973842723717880, -0.971604335300769, -0.969275439537199, -0.966856253369570, -0.964347002151056, -0.961747919624611, -0.959059247901202, -0.956281237437247, -0.953414147011291, -0.950458243699897, -0.947413802852767, -0.944281108067096, -0.941060451161149, -0.937752132147080, -0.934356459202989, -0.930873748644204, -0.927304324893829, -0.923648520452511, -0.919906675867474, -0.916079139700795, -0.912166268496933, -0.908168426749516, -0.904085986867389, -0.899919329139921, -0.895668841701585, -0.891334920495795, -0.886917969238029, -0.882418399378219, -0.877836630062424, -0.873173088093787, -0.868428207892773, -0.863602431456707, -0.858696208318596, -0.853709995505260, -0.848644257494751, -0.843499466173092, -0.838276100790317, -0.832974647915827, -0.827595601393068, -0.822139462293524, -0.816606738870046, -0.810997946509501, -0.805313607684768, -0.799554251906064, -0.793720415671624, -0.787812642417716, -0.781831482468030, -0.775777492982405, -0.769651237904932, -0.763453287911421, -0.757184220356241, -0.750844619218537, -0.744435075047831, -0.737956184909013, -0.731408552326720, -0.724792787229120, -0.718109505891090, -0.711359330876813, -0.704542890981785, -0.697660821174238, -0.690713762535992, -0.683702362202739, -0.676627273303758, -0.669489154901075, -0.662288671928070, -0.655026495127541, -0.647703300989211, -0.640319771686725, -0.632876595014096, -0.625374464321637, -0.617814078451373, -0.610196141671944, -0.602521363612998, -0.594790459199090, -0.587004148583085, -0.579163157079069, -0.571268215094792, -0.563320058063622, -0.555319426376040, -0.547267065310674, -0.539163724964869, -0.531010160184815, -0.522807130495235, -0.514555400028628, -0.506255737454095, -0.497908915905726, -0.489515712910590, -0.481076910316301, -0.472593294218187, -0.464065654886068, -0.455494786690634, -0.446881488029453, -0.438226561252594, -0.429530812587888, -0.420795052065827, -0.412020093444107, -0.403206754131820, -0.394355855113319, -0.385468220871733, -0.376544679312171, -0.367586061684596, -0.358593202506390, -0.349566939484627, -0.340508113438026, -0.331417568218635, -0.322296150633221, -0.313144710364388, -0.303964099891426, -0.294755174410904, -0.285518791757002, -0.276255812321605, -0.266967098974152, -0.257653516981261, -0.248315933926128, -0.238955219627703, -0.229572246059670, -0.220167887269220, -0.210743019295632, -0.201298520088660, -0.191835269426763, -0.182354148835141, -0.172856041503620, -0.163341832204388, -0.153812407209567, -0.144268654208661, -0.134711462225862, -0.125141721537235, -0.115560323587791, -0.105968160908443, -0.096366127032863, -0.086755116414251, -0.077136024342015, -0.067509746858365, -0.057877180674854, -0.048239223088843, -0.038596771899913, -0.028950725326236, -0.019301981920904, -0.009651440488226, -0.000000000000000 };

int32_t ADS_values_DMA[16] = {0};

#pragma DATA_SECTION(cla_phase_aux, "Cla1DataRam");
cla_phase_t cla_phase_aux;
#pragma DATA_SECTION(cla_phase_a, "Cla1DataRam");
cla_phase_t cla_phase_a;
#pragma DATA_SECTION(cla_phase_b, "Cla1DataRam");
cla_phase_t cla_phase_b;
#pragma DATA_SECTION(cla_phase_c, "Cla1DataRam");
cla_phase_t cla_phase_c;


bool flag_zc = false; //zero crossing mark



// Amostragem e janela de ciclo
#define FS_HZ            40000
#define F_MIN_HZ         40
#define NMAX_PER_CYCLE   (FS_HZ / F_MIN_HZ)   // 1000

// Ring por canal: >= 2×NMAX e potência de 2 (usa máscara)
#define RING_CAP         2048
#define RING_MASK        (RING_CAP - 1)

#define SPLINE_OUTPUT_SIZE 512

// Ring SoA (um vetor por canal) — na SDRAM se quiser
__attribute__((far)) volatile float32_t ring_vn[RING_CAP];
__attribute__((far)) volatile float32_t ring_in[RING_CAP];
__attribute__((far)) volatile float32_t ring_va[RING_CAP];
__attribute__((far)) volatile float32_t ring_ia[RING_CAP];
__attribute__((far)) volatile float32_t ring_vb[RING_CAP];
__attribute__((far)) volatile float32_t ring_ib[RING_CAP];
__attribute__((far)) volatile float32_t ring_vc[RING_CAP];
__attribute__((far)) volatile float32_t ring_ic[RING_CAP];

typedef struct {
    uint32_t wr_idx;    // índice global (monotônico), 1-past-last
    uint32_t last_end;  // índice global do fim do ciclo passado
    uint32_t start;     // índice global do início do ciclo (antes do &MASK)
    uint16_t count;     // nº de amostras no ciclo
} cycle_desc_t;
volatile cycle_desc_t cycle_desc = {0};   // “descritor” do último ciclo

#pragma DATA_SECTION(v_vector, "Cla1DataRam");
float32_t v_vector[SPLINE_OUTPUT_SIZE];
#pragma DATA_SECTION(i_vector, "Cla1DataRam");
float32_t i_vector[SPLINE_OUTPUT_SIZE];
float32_t dx_vector[SPLINE_OUTPUT_SIZE];
#pragma DATA_SECTION(cla_test_aux, "Cla1DataRam");
cla_meter_test_t cla_test_aux;

ledtest_rt_t meter_test;


// zc filter coeficients
static const filter_bandpass_order1_st fbp_43hz_84hz = {
                                                        .b0 =  4.189885981523826e-03f,
                                                        .b1 =  0.0f,
                                                        .b2 = -4.189885981523826e-03f,
                                                        .a0 =  1.0f,
                                                        .a1 = -1.991470261811710f,
                                                        .a2 =  0.991620228036952f,
                                                        .x_1 = 0, .x_2 = 0, .y_1 = 0, .y_2 = 0
};

#define FS   (20e6f/512.0f)
#define TS   (1.0f/FS)

zc_ctx_t zcA, zcB, zcC;

void app_init_cpu1(application_t *app)
{
    app->app_cpu1_state = APP_STATE_START;
    uint8_t address = 0;

    _app_gpio_init();

    I2CA_init();
    I2CB_init();
    DELAY_US(200000);

    _cla1_init();

    if(GPIO_ReadPin(MY_ADDR_PIN0) == 1 )
        address|=0b001;
    if(GPIO_ReadPin(MY_ADDR_PIN1) == 1 )
        address|=0b010;
    if(GPIO_ReadPin(MY_ADDR_PIN2) == 1 )
        address|=0b100;

    app->id.data.full.my_address = address;

    memcpy(app->id.data.full.probewell_part_number, "9015-6040       ", 16);
    memcpy(app->id.data.full.serial_number,         "22531515        ", 16);
    memcpy(app->id.data.full.fabrication_date,      "20240605", 8);
    memcpy(app->id.data.full.last_verfication_date, "20240605", 8);

    zc_init(&zcA, &fbp_43hz_84hz, TS);
    zc_init(&zcB, &fbp_43hz_84hz, TS);
    zc_init(&zcC, &fbp_43hz_84hz, TS);

    Cla1ForceTask8andWait();
    WAITSTEP;

    si5351c_init();
    si5351c2_init();

    ADS1278_init();

    led_pwm_init_for_fast_update();
    zpt_init_timer_fast();

    GPIO_setPadConfig(PULSE_IN_GPIO_PIN, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(PULSE_IN_GPIO_PIN, GPIO_DIR_MODE_IN);
    GPIO_setQualificationMode(PULSE_IN_GPIO_PIN, GPIO_QUAL_6SAMPLE);
    // GPIO_setQualificationPeriod(3,510);
    // GPIO_setQualificationMode(PULSE_IN_GPIO_PIN, GPIO_QUAL_ASYNC);
    GPIO_setPinConfig(PULSE_IN_GPIO_CFG);

    Interrupt_register(INT_XINT1, &xint1_isr);
    Interrupt_enable(INT_XINT1);
    GPIO_setInterruptPin(PULSE_IN_GPIO_PIN, GPIO_INT_XINT1);
    GPIO_setInterruptType(GPIO_INT_XINT1, GPIO_INT_TYPE_FALLING_EDGE);
    GPIO_enableInterrupt(GPIO_INT_XINT1); // Enable XINT1

}



float f = 5e3;

bool flag_f = false;
bool flag_f1 = false;
bool flag_f2 = false;
bool flag_f3 = false;




extern IPC_MessageQueue_t messageQueue;
extern IPC_Message_t      TxMsg;



ledtest_cfg_t cfg = {
                     .debounce_us           = 1e-6,
                     .kh_imp_per_kwh        = 10000,
                     .max_test_ms           = 1e6,
                     .start_on_first_pulse  = 1,
                     .target_pulses = 1
};



void app_run_cpu1(application_t *app)
{
    my_time_t time_actual = 0;
    time_actual = my_time(NULL);

    if(flag_f){
        flag_f = false;
        led_pwm_set_frequency_fast(f);
    }
    if(flag_f1){
        flag_f1 = false;
        led_pwm_set_frequency_slow(f);
    }

    if(flag_f2){
        flag_f2 = false;
        flag_f3 = true;
        f = cla_phase_a.w_cycle;
        led_pwm_set_frequency_slow(f);
    }

    if(flag_f3){
        f = cla_phase_a.w_cycle;
        led_pwm_set_frequency_fast(f);
    }





    // Poll uma mensagem vinda da CPU2 e despache (se existir)
    ipc_rx_service_cpu1();

    //    // (opcional) se a CPU1 também envia para a CPU2, limpe o flag após ACK:
    //    ipc_tx_service(); // sua função CPU1 que faz clear do C1->C2 após ver g_c2_to_c1_ack


    switch (app->app_cpu1_state) {

    case APP_STATE_IDLE:
        app->app_cpu1_state = APP_STATE_START;
        break;

    case APP_STATE_START:

    {
        int k;
        led_pwm_init_for_fast_update();

        _init_phase(&app->meter.phase[PHASE_A], PHASE_A, &app->meter.analog_input[7], &app->meter.analog_input[6] );
        _init_phase(&app->meter.phase[PHASE_B], PHASE_B, &app->meter.analog_input[4], &app->meter.analog_input[3] );
        _init_phase(&app->meter.phase[PHASE_C], PHASE_C, &app->meter.analog_input[3], &app->meter.analog_input[2] );
        _init_phase(&app->meter.phase[NEUTRAL], NEUTRAL, &app->meter.analog_input[1], &app->meter.analog_input[0] );

        ipc_simple_init_cpu1();

        for (k = 0; k<3; k++)
        {
            app->meter.phase[1].cal_tx->current_cal[k]   =   cla_phase_a.cal.current_cal[k];
            app->meter.phase[1].cal_tx->voltage_cal[k]   =   cla_phase_a.cal.voltage_cal[k];
            app->meter.phase[1].cal_tx->alpha[k]         =   cla_phase_a.cal.alpha[k]      ;

            app->meter.phase[2].cal_tx->current_cal[k]   =   cla_phase_b.cal.current_cal[k];
            app->meter.phase[2].cal_tx->voltage_cal[k]   =   cla_phase_b.cal.voltage_cal[k];
            app->meter.phase[2].cal_tx->alpha[k]         =   cla_phase_b.cal.alpha[k]      ;

            app->meter.phase[3].cal_tx->current_cal[k]   =   cla_phase_c.cal.current_cal[k];
            app->meter.phase[3].cal_tx->voltage_cal[k]   =   cla_phase_c.cal.voltage_cal[k];
            app->meter.phase[3].cal_tx->alpha[k]         =   cla_phase_c.cal.alpha[k]      ;
        }
        app->meter.phase[1].current_cal_index = 1;
        app->meter.phase[2].current_cal_index = 1;
        app->meter.phase[3].current_cal_index = 1;

        // Enable Global Interrupt (INTM) and real time interrupt (DBGM)
        EINT;
        ERTM;
    }

    app->app_cpu1_state = APP_STATE_RUNNING;
    break;

    case APP_STATE_RUNNING:

        GPIO_writePin(GPIO_DEBUG_2,1);
        // pegar o ciclo pronto


        if(flag_start_test){

            //    cla_test.flag_testing = false;
            //    cla_test.led_energy = 0.0f;
            //    cla_test.energy_measured = 0.0f;
            //    cla_test.energy_acc_uwh = 0;
            //    cla_test.energy_acc_wh = 0;
            //    cla_test.pulses_generated = 0;
            //    cla_test.flag_test_done = false;
            //    cla_test.pulses_expected = data[i+0];
            //    cla_test.flag_start_test = true;


            cfg.debounce_us           = 1e-6;
            cfg.kh_imp_per_kwh        = 10000;
            cfg.max_test_ms           = 1e6;
            cfg.start_on_first_pulse  = 1;
            cfg.target_pulses = 10;

            ledtest_begin(&cfg);

            flag_start_test = false;
        }

        if(meter_test.state == LEDTEST_DONE){

            ledtest_begin(&cfg);
        }

        if(flag_reset_test){


            //    cla_test.flag_testing = false;
            //    cla_test.flag_start_test = false;
            //    cla_test.led_energy = 0.0f;
            //    cla_test.energy_measured = 0.0f;
            //    cla_test.energy_acc_uwh = 0;
            //    cla_test.energy_acc_wh = 0;
            //    cla_test.pulses_generated = 0;
            //    cla_test.flag_test_done = false;

            flag_reset_test = false;
        }



        if (flag_zc)
        {
            int k;
            {

                if( flag_new_range ) {

                    cla_phase_a.cal.current_cal_index = new_range;
                    cla_phase_b.cal.current_cal_index = new_range;
                    cla_phase_c.cal.current_cal_index = new_range;
                    app->meter.phase[1].current_cal_index = new_range;
                    app->meter.phase[2].current_cal_index = new_range;
                    app->meter.phase[3].current_cal_index = new_range;
                }

                for (k = 0; k<3; k++)
                {
                    if(flag_new_calibration)
                    {

                        if(new_cal_phase == 1){
                            if(new_cal_parameter == 0)
                                cla_phase_a.cal.current_cal[new_cal_index]   =   app->meter.phase[1].cal_rx->current_cal[new_cal_index]  ;
                            if(new_cal_parameter == 1)
                                cla_phase_a.cal.voltage_cal[new_cal_index]   =   app->meter.phase[1].cal_rx->voltage_cal[new_cal_index]  ;
                            if(new_cal_parameter == 2)
                                cla_phase_a.cal.alpha[new_cal_index]         =   app->meter.phase[1].cal_rx->alpha[new_cal_index]        ;
                        }
                        if(new_cal_phase == 2){
                            if(new_cal_parameter == 0)
                                cla_phase_b.cal.current_cal[new_cal_index]   =   app->meter.phase[2].cal_rx->current_cal[new_cal_index]  ;
                            if(new_cal_parameter == 1)
                                cla_phase_b.cal.voltage_cal[new_cal_index]   =   app->meter.phase[2].cal_rx->voltage_cal[new_cal_index]  ;
                            if(new_cal_parameter == 2)
                                cla_phase_b.cal.alpha[new_cal_index]         =   app->meter.phase[2].cal_rx->alpha[new_cal_index]        ;
                        }
                        if(new_cal_phase == 3){
                            if(new_cal_parameter == 0)
                                cla_phase_c.cal.current_cal[new_cal_index]   =   app->meter.phase[3].cal_rx->current_cal[new_cal_index]  ;
                            if(new_cal_parameter == 1)
                                cla_phase_c.cal.voltage_cal[new_cal_index]   =   app->meter.phase[3].cal_rx->voltage_cal[new_cal_index]  ;
                            if(new_cal_parameter == 2)
                                cla_phase_c.cal.alpha[new_cal_index]         =   app->meter.phase[3].cal_rx->alpha[new_cal_index]        ;
                        }
                        flag_new_calibration = false;
                    }

                    app->meter.phase[1].cal_tx->current_cal[k]   =   cla_phase_a.cal.current_cal[k]  ;
                    app->meter.phase[1].cal_tx->voltage_cal[k]   =   cla_phase_a.cal.voltage_cal[k]  ;
                    app->meter.phase[1].cal_tx->alpha[k]         =   cla_phase_a.cal.alpha[k]        ;

                    app->meter.phase[2].cal_tx->current_cal[k]   =   cla_phase_b.cal.current_cal[k]  ;
                    app->meter.phase[2].cal_tx->voltage_cal[k]   =   cla_phase_b.cal.voltage_cal[k]  ;
                    app->meter.phase[2].cal_tx->alpha[k]         =   cla_phase_b.cal.alpha[k]        ;

                    app->meter.phase[3].cal_tx->current_cal[k]   =   cla_phase_c.cal.current_cal[k]  ;
                    app->meter.phase[3].cal_tx->voltage_cal[k]   =   cla_phase_c.cal.voltage_cal[k]  ;
                    app->meter.phase[3].cal_tx->alpha[k]         =   cla_phase_c.cal.alpha[k]        ;
                }


            }








            int cnt  = cycle_desc.count;                 // nº de amostras do ciclo
            int last = ((cycle_desc.start + cnt - 1) & RING_MASK);  // índice da ÚLTIMA amostra
            float32_t dx = (float32_t)cnt / (float32_t)SPLINE_OUTPUT_SIZE;         // mapeia [0..cnt)

            {
                // calcular os coeficientes a partir do ring
                calc_spline_coef_ring_idx((float32_t*)ring_va,   // ring é volatile -> faça cast
                                          RING_CAP,
                                          cnt,
                                          last,
                                          RING_MASK);


                // reamostrar: 512 pontos ao longo do ciclo

                for (k = 0; k < SPLINE_OUTPUT_SIZE; ++k)
                {
                    dx_vector[k] = k * dx;   // xi em [0, cnt)
                    v_vector[k] = calc_spline_value(dx_vector[k], cnt);
                }

                // calcular os coeficientes a partir do ring
                calc_spline_coef_ring_idx((float32_t*)ring_ia,   // ring é volatile -> faça cast
                                          RING_CAP,
                                          cnt,
                                          last,
                                          RING_MASK);

                // reamostrar: 512 pontos ao longo do ciclo
                for (k = 0; k < SPLINE_OUTPUT_SIZE; ++k)
                {
                    i_vector[k] = calc_spline_value(dx_vector[k], cnt);
                }


                Cla1ForceTask1();
            }

            {
                // calcular os coeficientes a partir do ring
                calc_spline_coef_ring_idx((float32_t*)ring_vb,   // ring é volatile -> faça cast
                                          RING_CAP,
                                          cnt,
                                          last,
                                          RING_MASK);


                // reamostrar: 512 pontos ao longo do ciclo

                for (k = 0; k < SPLINE_OUTPUT_SIZE; ++k)
                {
                    v_vector[k] = calc_spline_value(dx_vector[k], cnt);

                }

                // calcular os coeficientes a partir do ring
                calc_spline_coef_ring_idx((float32_t*)ring_ib,   // ring é volatile -> faça cast
                                          RING_CAP,
                                          cnt,
                                          last,
                                          RING_MASK);


                // reamostrar: 512 pontos ao longo do ciclo
                for (k = 0; k < SPLINE_OUTPUT_SIZE; ++k)
                {
                    i_vector[k] = calc_spline_value(dx_vector[k], cnt);
                }
                Cla1ForceTask2();
            }

            {
                calc_spline_coef_ring_idx((float32_t*)ring_vc,   // ring é volatile -> faça cast
                                          RING_CAP,
                                          cnt,
                                          last,
                                          RING_MASK);

                // reamostrar: 512 pontos ao longo do ciclo
                for (k = 0; k < SPLINE_OUTPUT_SIZE; ++k)
                {
                    v_vector[k] = calc_spline_value(dx_vector[k], cnt);
                }

                // calcular os coeficientes a partir do ring
                calc_spline_coef_ring_idx((float32_t*)ring_ic,   // ring é volatile -> faça cast
                                          RING_CAP,
                                          cnt,
                                          last,
                                          RING_MASK);

                // reamostrar: 512 pontos ao longo do ciclo
                for (k = 0; k < SPLINE_OUTPUT_SIZE; ++k)
                {
                    i_vector[k] = calc_spline_value(dx_vector[k], cnt);
                }
                Cla1ForceTask3();
            }

            {
                // calcular os coeficientes a partir do ring
                calc_spline_coef_ring_idx((float32_t*)ring_vb,   // ring é volatile -> faça cast
                                          RING_CAP,
                                          cnt,
                                          last,
                                          RING_MASK);

                // reamostrar: 512 pontos ao longo do ciclo

                for (k = 0; k < SPLINE_OUTPUT_SIZE; ++k)
                {
                    v_vector[k] = calc_spline_value(dx_vector[k], cnt);
                }

                // calcular os coeficientes a partir do ring
                calc_spline_coef_ring_idx((float32_t*)ring_in,   // ring é volatile -> faça cast
                                          RING_CAP,
                                          cnt,
                                          last,
                                          RING_MASK);

                // reamostrar: 512 pontos ao longo do ciclo
                for (k = 0; k < SPLINE_OUTPUT_SIZE; ++k)
                {
                    i_vector[k] = calc_spline_value(dx_vector[k], cnt);
                }
                Cla1ForceTask4();
            }

            flag_zc = false;
        }



        GPIO_writePin(GPIO_DEBUG_2,0);

        break;

    case APP_STATE_ERROR:
        break;
    }
}



void _app_gpio_init(void)
{

    GPIO_setPadConfig(GPIO_DEBUG_0, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(GPIO_DEBUG_0, GPIO_DIR_MODE_OUT);
    GPIO_setQualificationMode(GPIO_DEBUG_0, GPIO_QUAL_ASYNC);
    GPIO_setPinConfig(GPIO_DEBUG_0_CONFIG);
    GPIO_setMasterCore(GPIO_DEBUG_0, GPIO_CORE_CPU1);

    GPIO_setPadConfig(GPIO_DEBUG_1, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(GPIO_DEBUG_1, GPIO_DIR_MODE_OUT);
    GPIO_setQualificationMode(GPIO_DEBUG_1, GPIO_QUAL_ASYNC);
    GPIO_setPinConfig(GPIO_DEBUG_1_CONFIG);
    GPIO_setMasterCore(GPIO_DEBUG_1, GPIO_CORE_CPU1_CLA1);

    GPIO_setPadConfig(GPIO_DEBUG_2, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(GPIO_DEBUG_2, GPIO_DIR_MODE_OUT);
    GPIO_setQualificationMode(GPIO_DEBUG_2, GPIO_QUAL_ASYNC);
    GPIO_setPinConfig(GPIO_DEBUG_2_CONFIG);
    GPIO_setMasterCore(GPIO_DEBUG_2, GPIO_CORE_CPU1);

    GPIO_WritePin(GPIO_DEBUG_0, 0);
    GPIO_WritePin(GPIO_DEBUG_1, 0);
    GPIO_WritePin(GPIO_DEBUG_2, 0);


    GPIO_setPadConfig(MY_ADDR_PIN0, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(MY_ADDR_PIN0, GPIO_DIR_MODE_IN);
    GPIO_setQualificationMode(MY_ADDR_PIN0, GPIO_QUAL_6SAMPLE);
    GPIO_setPinConfig(MY_ADDR_PIN0_CONFIG);
    GPIO_setPadConfig(MY_ADDR_PIN1, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(MY_ADDR_PIN1, GPIO_DIR_MODE_IN);
    GPIO_setQualificationMode(MY_ADDR_PIN1, GPIO_QUAL_6SAMPLE);
    GPIO_setPinConfig(MY_ADDR_PIN1_CONFIG);
    GPIO_setPadConfig(MY_ADDR_PIN2, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(MY_ADDR_PIN2, GPIO_DIR_MODE_IN);
    GPIO_setQualificationMode(MY_ADDR_PIN2, GPIO_QUAL_6SAMPLE);
    GPIO_setPinConfig(MY_ADDR_PIN2_CONFIG);

    GPIO_setPadConfig(CLKGEN_ON, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(CLKGEN_ON, GPIO_DIR_MODE_OUT);
    GPIO_setQualificationMode(CLKGEN_ON, GPIO_QUAL_6SAMPLE);
    GPIO_setPinConfig(CLKGEN_ON_CONFIG);
    GPIO_WritePin(CLKGEN_ON, 1);

    GPIO_setPadConfig(CLKGEN_ADS_SEL_IN, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(CLKGEN_ADS_SEL_IN, GPIO_DIR_MODE_OUT);
    GPIO_setQualificationMode(CLKGEN_ADS_SEL_IN, GPIO_QUAL_6SAMPLE);
    GPIO_setPinConfig(CLKGEN_ADS_SEL_IN_CONFIG);
    GPIO_WritePin(CLKGEN_ADS_SEL_IN, 1);

    GPIO_setPadConfig(CLKGEN_ADS_SEL1_OUT, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(CLKGEN_ADS_SEL1_OUT, GPIO_DIR_MODE_OUT);
    GPIO_setQualificationMode(CLKGEN_ADS_SEL1_OUT, GPIO_QUAL_6SAMPLE);
    GPIO_setPinConfig(CLKGEN_ADS_SEL1_OUT_CONFIG);
    GPIO_WritePin(CLKGEN_ADS_SEL1_OUT, 1);

    GPIO_setPadConfig(CLKGEN_ADS_SEL2_OUT, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(CLKGEN_ADS_SEL2_OUT, GPIO_DIR_MODE_OUT);
    GPIO_setQualificationMode(CLKGEN_ADS_SEL2_OUT, GPIO_QUAL_6SAMPLE);
    GPIO_setPinConfig(CLKGEN_ADS_SEL2_OUT_CONFIG);
    GPIO_WritePin(CLKGEN_ADS_SEL2_OUT, 0);

    GPIO_setPadConfig(CLKGEN_BSP_ENA, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(CLKGEN_BSP_ENA, GPIO_DIR_MODE_OUT);
    GPIO_setQualificationMode(CLKGEN_BSP_ENA, GPIO_QUAL_6SAMPLE);
    GPIO_setPinConfig(CLKGEN_BSP_ENA_CONFIG);
    GPIO_WritePin(CLKGEN_BSP_ENA, 1);

    //    //fs 106
    //    GPIO_setPadConfig(106, GPIO_PIN_TYPE_STD);
    //    GPIO_setDirectionMode(106, GPIO_DIR_MODE_OUT);
    //    GPIO_setQualificationMode(106,GPIO_QUAL_6SAMPLE);
    //    GPIO_setPinConfig(GPIO_106_GPIO106);
    //    GPIO_WritePin(106, 1);
    //    //ssc0 107
    //    GPIO_setPadConfig(107, GPIO_PIN_TYPE_STD);
    //    GPIO_setDirectionMode(107, GPIO_DIR_MODE_OUT);
    //    GPIO_setQualificationMode(107,GPIO_QUAL_6SAMPLE);
    //    GPIO_setPinConfig(GPIO_107_GPIO107);
    //    GPIO_WritePin(107, 0);
    //    //ssc1 167
    //    GPIO_setPadConfig(167, GPIO_PIN_TYPE_STD);
    //    GPIO_setDirectionMode(167, GPIO_DIR_MODE_OUT);
    //    GPIO_setQualificationMode(167,GPIO_QUAL_6SAMPLE);
    //    GPIO_setPinConfig(GPIO_167_GPIO167);
    //    GPIO_WritePin(167, 0);

    GPIO_setPadConfig(Si5341B_RST, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(Si5341B_RST, GPIO_DIR_MODE_OUT);
    GPIO_setQualificationMode(Si5341B_RST, GPIO_QUAL_6SAMPLE);
    GPIO_setPinConfig(Si5341B_RST_CONFIG);
    GPIO_WritePin(Si5341B_RST, 0);

    GPIO_setPadConfig(Si5341B_OE, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(Si5341B_OE, GPIO_DIR_MODE_OUT);
    GPIO_setQualificationMode(Si5341B_OE, GPIO_QUAL_6SAMPLE);
    GPIO_setPinConfig(Si5341B_OE_CONFIG);
    GPIO_WritePin(Si5341B_OE, 0);

    // I2C
    {
        // I2CA -> clock to ADS1278
        GPIO_setDirectionMode(SDA_ADS, GPIO_DIR_MODE_OUT);
        GPIO_setPadConfig(SDA_ADS, GPIO_PIN_TYPE_STD);
        GPIO_setMasterCore(SDA_ADS, GPIO_CORE_CPU1);
        GPIO_setQualificationMode(SDA_ADS, GPIO_QUAL_ASYNC);
        GPIO_setPinConfig(SDA_ADS_CONFIG);
        GPIO_setMasterCore(SDA_ADS, GPIO_CORE_CPU1);

        GPIO_setDirectionMode(SCL_ADS, GPIO_DIR_MODE_OUT);
        GPIO_setPadConfig(SCL_ADS, GPIO_PIN_TYPE_STD);
        GPIO_setMasterCore(SCL_ADS, GPIO_CORE_CPU1);
        GPIO_setQualificationMode(SCL_ADS, GPIO_QUAL_ASYNC);
        GPIO_setPinConfig(SCL_ADS_CONFIG);
        GPIO_setMasterCore(SCL_ADS, GPIO_CORE_CPU1);

        // I2Cb -> clock to Generators
        GPIO_setDirectionMode(SDA_GEN, GPIO_DIR_MODE_OUT);
        GPIO_setPadConfig(SDA_GEN, GPIO_PIN_TYPE_PULLUP);
        GPIO_setMasterCore(SDA_GEN, GPIO_CORE_CPU1);
        GPIO_setQualificationMode(SDA_GEN, GPIO_QUAL_ASYNC);
        GPIO_setPinConfig(SDA_GEN_CONFIG);
        GPIO_setMasterCore(SDA_GEN, GPIO_CORE_CPU1);

        GPIO_setDirectionMode(SCL_GEN, GPIO_DIR_MODE_OUT);
        GPIO_setPadConfig(SCL_GEN, GPIO_PIN_TYPE_PULLUP);
        GPIO_setMasterCore(SCL_GEN, GPIO_CORE_CPU1);
        GPIO_setQualificationMode(SCL_GEN, GPIO_QUAL_ASYNC);
        GPIO_setPinConfig(SCL_GEN_CONFIG);
        GPIO_setMasterCore(SCL_GEN, GPIO_CORE_CPU1);


    }

    // Initialize SCI
    {
        //CLI
        GPIO_setPinConfig(CLI_SCIRX_GPIO_PIN_CONFIG);
        GPIO_setPinConfig(CLI_SCITX_GPIO_PIN_CONFIG);
        GPIO_setQualificationMode(CLI_SCITX_GPIO, GPIO_QUAL_ASYNC);
        GPIO_setQualificationMode(CLI_SCIRX_GPIO, GPIO_QUAL_ASYNC);

        //COMM
        GPIO_setPinConfig(COMMS_SCIRX_GPIO_PIN_CONFIG);
        GPIO_setPinConfig(COMMS_SCITX_GPIO_PIN_CONFIG);
        GPIO_setQualificationMode(COMMS_SCITX_GPIO, GPIO_QUAL_ASYNC);
        GPIO_setQualificationMode(COMMS_SCIRX_GPIO, GPIO_QUAL_ASYNC);
    }
    //SPI
    {
        //SPIA
        GPIO_setPinConfig(SPIA_MOSI_PIN_CONFIG);
        GPIO_setPadConfig(SPIA_MOSI_GPIO, GPIO_PIN_TYPE_STD);
        GPIO_setQualificationMode(SPIA_MOSI_GPIO, GPIO_QUAL_ASYNC);
        GPIO_setMasterCore(SPIA_MOSI_GPIO, GPIO_CORE_CPU1);

        GPIO_setPinConfig(SPIA_MISO_PIN_CONFIG);
        GPIO_setPadConfig(SPIA_MISO_GPIO, GPIO_PIN_TYPE_STD);
        GPIO_setQualificationMode(SPIA_MISO_GPIO, GPIO_QUAL_ASYNC);
        GPIO_setMasterCore(SPIA_MISO_GPIO, GPIO_CORE_CPU1);

        GPIO_setPinConfig(SPIA_CLK_PIN_CONFIG);
        GPIO_setPadConfig(SPIA_CLK_GPIO, GPIO_PIN_TYPE_STD);
        GPIO_setQualificationMode(SPIA_CLK_GPIO, GPIO_QUAL_ASYNC);
        GPIO_setMasterCore(SPIA_CLK_GPIO, GPIO_CORE_CPU1);


        //    //SPIB
        //    GPIO_setPinConfig(SPIB_MOSI_PIN_CONFIG);
        //    GPIO_setPadConfig(SPIB_MOSI_GPIO, GPIO_PIN_TYPE_STD);
        //    GPIO_setQualificationMode(SPIB_MOSI_GPIO, GPIO_QUAL_ASYNC);
        //
        //    GPIO_setPinConfig(SPIB_MISO_PIN_CONFIG);
        //    GPIO_setPadConfig(SPIB_MISO_GPIO, GPIO_PIN_TYPE_STD);
        //    GPIO_setQualificationMode(SPIB_MISO_GPIO, GPIO_QUAL_ASYNC);
        //
        //    GPIO_setPinConfig(SPIB_CLK_PIN_CONFIG);
        //    GPIO_setPadConfig(SPIB_CLK_GPIO, GPIO_PIN_TYPE_STD);
        //    GPIO_setQualificationMode(SPIB_CLK_GPIO, GPIO_QUAL_ASYNC);



        //CS
        GPIO_writePin(GPIO_PIN_CS_A1,1);
        GPIO_setDirectionMode(GPIO_PIN_CS_A1,GPIO_DIR_MODE_OUT);
        GPIO_setQualificationMode(GPIO_PIN_CS_A1,GPIO_QUAL_ASYNC);
        GPIO_setPinConfig(GPIO_PIN_CS_A1_PIN_CONFIG);
        GPIO_setMasterCore(GPIO_PIN_CS_A1, GPIO_CORE_CPU2);

        GPIO_writePin(GPIO_PIN_CS_A2,1);
        GPIO_setDirectionMode(GPIO_PIN_CS_A2,GPIO_DIR_MODE_OUT);
        GPIO_setQualificationMode(GPIO_PIN_CS_A2,GPIO_QUAL_ASYNC);
        GPIO_setPinConfig(GPIO_PIN_CS_A2_PIN_CONFIG);
        GPIO_setMasterCore(GPIO_PIN_CS_A2, GPIO_CORE_CPU2);

        GPIO_writePin(GPIO_PIN_CS_A3,1);
        GPIO_setDirectionMode(GPIO_PIN_CS_A3,GPIO_DIR_MODE_OUT);
        GPIO_setQualificationMode(GPIO_PIN_CS_A3,GPIO_QUAL_ASYNC);
        GPIO_setPinConfig(GPIO_PIN_CS_A3_PIN_CONFIG);
        GPIO_setMasterCore(GPIO_PIN_CS_A3, GPIO_CORE_CPU2);

        GPIO_writePin(GPIO_PIN_CS_A4,1);
        GPIO_setDirectionMode(GPIO_PIN_CS_A4,GPIO_DIR_MODE_OUT);
        GPIO_setQualificationMode(GPIO_PIN_CS_A4,GPIO_QUAL_ASYNC);
        GPIO_setPinConfig(GPIO_PIN_CS_A4_PIN_CONFIG);
        GPIO_setMasterCore(GPIO_PIN_CS_A4, GPIO_CORE_CPU2);

        GPIO_writePin(GPIO_PIN_CS_A5,1);
        GPIO_setDirectionMode(GPIO_PIN_CS_A5,GPIO_DIR_MODE_OUT);
        GPIO_setQualificationMode(GPIO_PIN_CS_A5,GPIO_QUAL_ASYNC);
        GPIO_setPinConfig(GPIO_PIN_CS_A5_PIN_CONFIG);
        GPIO_setMasterCore(GPIO_PIN_CS_A5, GPIO_CORE_CPU2);

        GPIO_writePin(GPIO_PIN_CS_A6,1);
        GPIO_setDirectionMode(GPIO_PIN_CS_A6,GPIO_DIR_MODE_OUT);
        GPIO_setQualificationMode(GPIO_PIN_CS_A6,GPIO_QUAL_ASYNC);
        GPIO_setPinConfig(GPIO_PIN_CS_A6_PIN_CONFIG);
        GPIO_setMasterCore(GPIO_PIN_CS_A6, GPIO_CORE_CPU2);

        GPIO_writePin(GPIO_PIN_CS_A7,1);
        GPIO_setDirectionMode(GPIO_PIN_CS_A7,GPIO_DIR_MODE_OUT);
        GPIO_setQualificationMode(GPIO_PIN_CS_A7,GPIO_QUAL_ASYNC);
        GPIO_setPinConfig(GPIO_PIN_CS_A7_PIN_CONFIG);
        GPIO_setMasterCore(GPIO_PIN_CS_A7, GPIO_CORE_CPU2);

        GPIO_writePin(GPIO_PIN_CS_A8,1);
        GPIO_setDirectionMode(GPIO_PIN_CS_A8,GPIO_DIR_MODE_OUT);
        GPIO_setQualificationMode(GPIO_PIN_CS_A8,GPIO_QUAL_ASYNC);
        GPIO_setPinConfig(GPIO_PIN_CS_A8_PIN_CONFIG);
        GPIO_setMasterCore(GPIO_PIN_CS_A8, GPIO_CORE_CPU2);
    }

    { //buzzer

        GPIO_setPadConfig(168, GPIO_PIN_TYPE_STD);
        GPIO_setDirectionMode(168, GPIO_DIR_MODE_OUT);
        GPIO_setQualificationMode(168, GPIO_QUAL_ASYNC);
        GPIO_setPinConfig(GPIO_168_EPWM12B);
        GPIO_setMasterCore(168, GPIO_CORE_CPU2);
    }
}




void ADS1278_init(void)
{
    ADS1278_initControls();

    McBSPB_pin_config();
    //    McBSP_config_bitregs();
    McBSP_config_funcs();
    configDMA_ADS1278();

    DMA_startChannel(DMA_CH1_BASE);
    McBSP_enableReceiver(MCBSPB_BASE);
    MCBSP_CYCLE_NOP(8);

    ADS1278_sync();
}



void ADS1278_sync(void) {
    GPIO_writePin(GPIO_ADS_SYNC,0);            // Set ADS1278 SYNC to 0
    NOP;NOP;
    GPIO_writePin(GPIO_ADS_SYNC,1);
}





void ADS1278_initControls(void) {

    // TEST0, TEST1
    GPIO_writePin(GPIO_ADC_TEST1,0);                               // TEST[1:0] Test mode select:
    GPIO_setDirectionMode(GPIO_ADC_TEST1,GPIO_DIR_MODE_OUT);       //
    GPIO_setQualificationMode(GPIO_ADC_TEST1,GPIO_QUAL_ASYNC);     // 00 = Normal operation    01 = Do not use
    GPIO_setPinConfig(GPIO_ADC_TEST1_PIN_CONFIG);                  // 11 = Test mode           10 = Do not use

    GPIO_writePin(GPIO_ADC_TEST0,0);
    GPIO_setDirectionMode(GPIO_ADC_TEST0,GPIO_DIR_MODE_OUT);
    GPIO_setQualificationMode(GPIO_ADC_TEST0,GPIO_QUAL_ASYNC);
    GPIO_setPinConfig(GPIO_ADC_TEST0_PIN_CONFIG);

    // CLKDIV
    GPIO_writePin(GPIO_ADC_CLKDIV,1);                              // 1 = 37MHz (High-Speed mode)/otherwise 27MHz
    GPIO_setDirectionMode(GPIO_ADC_CLKDIV,GPIO_DIR_MODE_OUT);      // 0 = 13.5MHz (low-power)/5.4MHz (low-speed)
    GPIO_setQualificationMode(GPIO_ADC_CLKDIV,GPIO_QUAL_ASYNC);
    GPIO_setPinConfig(GPIO_ADC_CLKDIV_PIN_CONFIG);

    // MODE0, MODE1
    GPIO_writePin(GPIO_ADC_MODE1,0);                               // MODE[1:0] Mode of operation
    GPIO_setDirectionMode(GPIO_ADC_MODE1,GPIO_DIR_MODE_OUT);       //
    GPIO_setQualificationMode(GPIO_ADC_MODE1,GPIO_QUAL_ASYNC);     // | MODE[1:0] | MODE SELECTION  | Data Rate |
    GPIO_setPinConfig(GPIO_ADC_MODE1_PIN_CONFIG);                  // |    00     | High-Speed      |  144531   |
    // |    01     | High-Resolution |   52734   |  << 
    GPIO_writePin(GPIO_ADC_MODE0,1);                               // |    10     | Low-Power       |   52734   |
    GPIO_setDirectionMode(GPIO_ADC_MODE0,GPIO_DIR_MODE_OUT);       // |    11     | Low-Speed       |   10547   |
    GPIO_setQualificationMode(GPIO_ADC_MODE0,GPIO_QUAL_ASYNC);
    GPIO_setPinConfig(GPIO_ADC_MODE0_PIN_CONFIG);

    // FORMAT2, FORMAT1, FORMAT0
    GPIO_writePin(GPIO_ADC_FORMAT2,0);                             // FORMAT[2:0] Data format (SPI or Frame-Sync)
    GPIO_setDirectionMode(GPIO_ADC_FORMAT2,GPIO_DIR_MODE_OUT);     //
    GPIO_setQualificationMode(GPIO_ADC_FORMAT2,GPIO_QUAL_ASYNC);   // | FORMAT[2:0] |  INTERFACE |   DOUT   | DATA POSITION |
    GPIO_setPinConfig(GPIO_ADC_FORMAT2_PIN_CONFIG);                // |     000     |     SPI    |   TDM    |    Dynamic    |
    // |     001     |     SPI    |   TDM    |     Fixed     |
    GPIO_writePin(GPIO_ADC_FORMAT1,0);                             // |     010     |     SPI    | Discrete |   ---------   |
    GPIO_setDirectionMode(GPIO_ADC_FORMAT1,GPIO_DIR_MODE_OUT);     // |     011     | Frame-Sync |   TDM    |    Dynamic    |
    GPIO_setQualificationMode(GPIO_ADC_FORMAT1,GPIO_QUAL_ASYNC);   // |     100     | Frame-Sync |   TDM    |     Fixed     |  <<
    GPIO_setPinConfig(GPIO_ADC_FORMAT1_PIN_CONFIG);                // |     101     | Frame-Sync | Discrete |   ---------   |
    // |     110     |  Modulator | -------- |   ---------   |
    GPIO_writePin(GPIO_ADC_FORMAT0,1);
    GPIO_setDirectionMode(GPIO_ADC_FORMAT0,GPIO_DIR_MODE_OUT);
    GPIO_setQualificationMode(GPIO_ADC_FORMAT0,GPIO_QUAL_ASYNC);
    GPIO_setPinConfig(GPIO_ADC_FORMAT0_PIN_CONFIG);

    // CLK_SEL
    GPIO_setPadConfig(GPIO_ADC_CLK_SEL, GPIO_PIN_TYPE_STD);                      // Push-pull output or floating input
    GPIO_setQualificationMode(GPIO_ADC_CLK_SEL, GPIO_QUAL_SYNC);                 // Synchronous Pin
    GPIO_setDirectionMode(GPIO_ADC_CLK_SEL, GPIO_DIR_MODE_OUT);                  // Set as output pin
    GPIO_setPinConfig(GPIO_ADC_CLK_SEL_PIN_CONFIG);
    GPIO_writePin(GPIO_ADC_CLK_SEL, 1);

    // ADS1278 SYNC
    GPIO_setPadConfig(GPIO_ADC_NSYNC, GPIO_PIN_TYPE_STD);                      // Push-pull output or floating input
    GPIO_setQualificationMode(GPIO_ADC_NSYNC, GPIO_QUAL_SYNC);                 // Synchronous Pin
    GPIO_setDirectionMode(GPIO_ADC_NSYNC, GPIO_DIR_MODE_OUT);                  // Set as output pin
    GPIO_setPinConfig(GPIO_ADC_NSYNC_PIN_CONFIG);
    GPIO_writePin(GPIO_ADC_NSYNC, 1);

}


void McBSPB_pin_config(void)
{

    // McBSP Setup GPIOs

    // SCK Pin
    GPIO_setPadConfig(3, GPIO_PIN_TYPE_STD);      // Push-pull output or floating input
    GPIO_setQualificationMode(3, GPIO_QUAL_SYNC); // Asynchronous Pin
    GPIO_setDirectionMode(3, GPIO_DIR_MODE_IN);   // Set as output pin
    GPIO_setPinConfig(GPIO_3_MCLKRB);             // McBSP-B receive clock

    // McBSP-B receive serial data (MISO)
    GPIO_setPadConfig(25, GPIO_PIN_TYPE_STD);      // Push-pull output or floating input
    GPIO_setQualificationMode(25, GPIO_QUAL_SYNC); // Asynchronous Pin
    GPIO_setDirectionMode(25, GPIO_DIR_MODE_IN);   // Set as input pin
    GPIO_setPinConfig(GPIO_25_MDRB);               // McBSP-B receive serial data

    // Frame Sync Pin
    GPIO_setPadConfig(1, GPIO_PIN_TYPE_STD);      // Push-pull output or floating input
    GPIO_setQualificationMode(1, GPIO_QUAL_SYNC); // Asynchronous Pin
    GPIO_setDirectionMode(1, GPIO_DIR_MODE_IN);   // Set as output pin
    GPIO_setPinConfig(GPIO_1_MFSRB);              // McBSP-B receive frame sync

    GPIO_setPadConfig(2, GPIO_PIN_TYPE_STD); // Config GPIO2 as input to avoid interference
    GPIO_setDirectionMode(2, GPIO_DIR_MODE_IN);
    GPIO_setQualificationMode(2, GPIO_QUAL_ASYNC);
    GPIO_setPinConfig(GPIO_2_GPIO2);

    GPIO_setPadConfig(GPIO_ADS_SYNC, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(GPIO_ADS_SYNC, GPIO_DIR_MODE_OUT);
    GPIO_setQualificationMode(GPIO_ADS_SYNC, GPIO_QUAL_ASYNC);
    GPIO_setPinConfig(GPIO_ADS_SYNC_CONFIG); // GPIO_14_GPIO14 or GPIO_14_EPWM8A
}


void McBSP_config_funcs(void)
{
    //
    // Reset FS generator, sample rate generator, transmitter, receiver.
    //
    McBSP_resetFrameSyncLogic(MCBSPB_BASE);
    McBSP_resetSampleRateGenerator(MCBSPB_BASE);
    McBSP_resetTransmitter(MCBSPB_BASE);
    McBSP_resetReceiver(MCBSPB_BASE);

    //
    // Set Rx sign-extension and justification mode.
    //
    McBSP_setRxSignExtension(MCBSPB_BASE, MCBSP_RIGHT_JUSTIFY_FILL_SIGN);

    //
    // Enable clock stop mode.
    //
    McBSP_setClockStopMode(MCBSPB_BASE, MCBSP_CLOCK_MCBSP_MODE);

    //
    // Set Rx & Tx delay to 1 cycle.
    //
    McBSP_setRxDataDelayBits(MCBSPB_BASE, MCBSP_DATA_DELAY_BIT_1);
    // McBSP_setTxDataDelayBits(MCBSPB_BASE, MCBSP_DATA_DELAY_BIT_1);

    //
    // Set CLKX & FSX source as sample rate generator.
    //
    // McBSP_setTxClockSource(MCBSPB_BASE, MCBSP_INTERNAL_TX_CLOCK_SOURCE);
    McBSP_setRxClockSource(MCBSPB_BASE, MCBSP_EXTERNAL_RX_CLOCK_SOURCE);
    // McBSP_setTxFrameSyncSource(MCBSPB_BASE, MCBSP_TX_INTERNAL_FRAME_SYNC_SOURCE);
    McBSP_setRxFrameSyncSource(MCBSPB_BASE, MCBSP_RX_EXTERNAL_FRAME_SYNC_SOURCE);
    McBSP_setRxFrameSyncPolarity(MCBSPB_BASE, MCBSP_RX_FRAME_SYNC_POLARITY_HIGH);
    //
    // Set Tx and Rx clock and frame-sync polarity.
    //
    // McBSP_setTxFrameSyncPolarity(MCBSPB_BASE, MCBSP_TX_FRAME_SYNC_POLARITY_LOW);
    // McBSP_setTxClockPolarity(MCBSPB_BASE, MCBSP_TX_POLARITY_RISING_EDGE);
    McBSP_setRxClockPolarity(MCBSPB_BASE, MCBSP_RX_POLARITY_RISING_EDGE);

    //
    // Initialize McBSP data length.
    //
    McBSP_setRxDataSize(MCBSPB_BASE, MCBSP_PHASE_ONE_FRAME,
                        MCBSP_BITS_PER_WORD_24, 7);
    // McBSP_setTxDataSize(MCBSPB_BASE, MCBSP_PHASE_ONE_FRAME,
    //                     MCBSP_BITS_PER_WORD_32, 0);

    //
    // Set frame synchronization pulse period to 1 CLKG cycle.
    //
    // McBSP_setFrameSyncPulsePeriod(MCBSPB_BASE, 1);

    //
    // Set frame-sync pulse width to  CLKG cycle.
    //
    // McBSP_setFrameSyncPulseWidthDivider(MCBSPB_BASE, 1);

    //
    // Set the trigger source for internally generated frame-sync pulse.
    //
    // McBSP_setTxInternalFrameSyncSource(MCBSPB_BASE,
    //                                   MCBSP_TX_INTERNAL_FRAME_SYNC_DATA);

    //
    // Set LSPCLK as input source for sample rate generator.
    //
    // McBSP_setTxSRGClockSource(MCBSPB_BASE, MCBSP_SRG_TX_CLOCK_SOURCE_LSPCLK);

    //
    // Set Divide down value for CLKG.
    //
    McBSP_setSRGDataClockDivider(MCBSPB_BASE, 3);

    //
    // Set  external clock sync for CLKG.
    //
    McBSP_disableSRGSyncFSR(MCBSPB_BASE);

    //
    // Wait for CPU cycles equivalent to 2 SRG cycles-init delay.
    // Total cycles required = 2*(SYSCLK/LSPCLK). In this example
    // LSPCLK = SYSCLK/4.
    //
    MCBSP_CYCLE_NOP(8);

    //
    // Enable Sample rate generator and wait for at least 2 CLKG clock cycles.
    //
    McBSP_enableSampleRateGenerator(MCBSPB_BASE);
    McBSP_enableFrameSyncLogic(MCBSPB_BASE);

    //
    // Wait for CPU cycles equivalent to 2 CLKG cycles-init delay.
    // Total cycles required = 2*(SYSCLK/(LSPCLK/(1+CLKGDV_VAL))). In this
    // example LSPCLK = SYSCLK/4 and CLKGDV_VAL = 1.
    //
    MCBSP_CYCLE_NOP(16);

    EALLOW;
    PieVectTable.MCBSPB_RX_INT = &mcbspb_rx_isr_adc; // ISR Mapping
    EDIS;

    IER |= M_INT6;
    PieCtrlRegs.PIEIER6.bit.INTx7 = 1; // Activate PIE Channel for McBSPB_RX

    // McBSP_enableRxInterrupt(MCBSPB_BASE);

    //
    // Release Rx, Tx and frame-sync generator from reset.
    //
    // McBSP_enableTransmitter(MCBSPB_BASE);
    // McBSP_enableReceiver(MCBSPB_BASE);

    //
    // Wait for CPU cycles equivalent to 2 SRG cycles-init delay.
    // Total cycles required = 2*(SYSCLK/LSPCLK). In this example
    // LSPCLK = SYSCLK/4.
    //
    MCBSP_CYCLE_NOP(8);

    //    McBSP_setRxDataDelayBits(MCBSPB_BASE, MCBSP_DATA_DELAY_BIT_1);
    //
    //    McBSP_setRxClockSource(MCBSPB_BASE, MCBSP_EXTERNAL_RX_CLOCK_SOURCE);
    //    McBSP_setRxFrameSyncSource(MCBSPB_BASE, MCBSP_RX_INTERNAL_FRAME_SYNC_SOURCE);
    //
    //    McBSP_setRxClockPolarity(MCBSPB_BASE, MCBSP_RX_POLARITY_RISING_EDGE);
    //
    //    //McBSP_setRxFrameSyncPolarity(MCBSPB_BASE, MCBSP_RX_FRAME_SYNC_POLARITY_LOW);
    //
    //    McBSP_setRxDataSize(MCBSPB_BASE, MCBSP_PHASE_ONE_FRAME,
    //                        MCBSP_BITS_PER_WORD_24, 8);
    //
    //    McBSP_setFrameSyncPulsePeriod(MCBSPB_BASE, 191);
    //    McBSP_setFrameSyncPulseWidthDivider(MCBSPB_BASE, 1);
    //
    //    McBSP_setSRGDataClockDivider(MCBSPB_BASE, 4);
    //    McBSP_disableSRGSyncFSR(MCBSPB_BASE);
    //
    //    McBSP_setEmulationMode(MCBSPB_BASE, MCBSP_EMULATION_FREE_RUN);
    //
    //    // McBSP_enableRxInterrupt(MCBSPB_BASE);
    //
    //    MCBSP_CYCLE_NOP(8);
    //
    //    McBSP_enableSampleRateGenerator(MCBSPB_BASE);
    //
    //    MCBSP_CYCLE_NOP(16);
    //
    //    McBSP_enableReceiver(MCBSPB_BASE);
    //    McBSP_enableFrameSyncLogic(MCBSPB_BASE);
}

void configDMA_ADS1278(void)
{

    const void *destAddr;
    const void *srcAddr;

    IER |= M_INT7;
    PieCtrlRegs.PIEIER7.bit.INTx1 = 1;

    srcAddr = (const void *)&McbspbRegs.DRR1;
    destAddr = (const void *)ADS_values_DMA;

    Interrupt_register(INT_DMA_CH1, dmaADSchannels);
    SysCtl_selectSecMaster(SYSCTL_SEC_MASTER_DMA, SYSCTL_SEC_MASTER_DMA); // Configure DMA as secondary master for peripheral frame 2.
    DMA_initController();

    DMA_configAddresses(DMA_CH1_BASE, destAddr, srcAddr);                                                                            // Configures the source and destination addresses of a DMA channel
    DMA_configBurst(DMA_CH1_BASE, 2, -1, 1);                                                                                         // Configure 2 word per burst. Increment one 16-bit address between words for src & dest address.
    DMA_configTransfer(DMA_CH1_BASE, 8, 0, 1);                                                                                       // Configure 8 bursts per transfer. For src move 0. For dest move 1 words.
    DMA_configWrap(DMA_CH1_BASE, 1, 0, 0, 0);                                                                                        // Configure wrap size to maximum to avoid wrapping.
    DMA_configMode(DMA_CH1_BASE, DMA_TRIGGER_MCBSPBMREVT, DMA_CFG_SIZE_16BIT | DMA_CFG_ONESHOT_DISABLE | DMA_CFG_CONTINUOUS_ENABLE); // DMA transfers 32 bits at a time, triggered by a Mcbspb read event
    DMA_setEmulationMode(DMA_EMULATION_FREE_RUN);

    DMA_setInterruptMode(DMA_CH1_BASE, DMA_INT_AT_END); // IRQ at all channels transfered
    DMA_enableTrigger(DMA_CH1_BASE);                    // Enables peripherals to trigger a DMA transfer
    DMA_enableInterrupt(DMA_CH1_BASE);                  // Enables a DMA channel interrupt source
}

__interrupt void mcbspb_rx_isr_adc(void)
{

    // static uint16_t A[2] = {0};
    // static uint8_t map_ads[8] = {7, 3, 6, 2, 5, 1, 4, 0};
    //     static uint8_t map_ads[8] = {0, 4, 1, 5, 2, 6, 3, 7};
    //     static uint16_t sample_count = 0;

    // DMA_triggerSoftReset(DMA_CH1_BASE);

    // A[0] = McbspbRegs.DRR1.all;
    // A[1] = McbspbRegs.DRR2.all;

    // ADS_values[index_tst] = (((((int32_t)A[1])<<16)+A[0])<<8)>>8;
    // ADS_floats[map_ads[index_tst]] = (0.000158412*ADS_values[index_tst]) + 0.57779; //1.226;
    //     ADS_floats[map_ads[index_tst]] = ((ADS_values[index_tst]*2.3838)/8388608.0) + ADS_offset[index_tst] - 1.1919;     //ads*ratio + dc_offset (8388608.0)
    //     ADS_floats[index_tst] = ((ADS_values[index_tst]*2.3838)/8388608.0) + ADS_offset[index_tst] - 1.1919;

    // FFT Buffer fill

    //    if (runFFT == 0){
    //        //
    //        //        if (sample_count == 0){
    //        if (fftBufIndex < sizeof(input_buff)){
    //            input_buff[fftBufIndex++] = ADS_floats[0];
    //            //            if(fftBufIndex == RFFT_SIZE){
    //            //                // if the full FFT size is reached, set the runFFT flag
    //            //                memcpy(IOBuffer, input_buff, sizeof(IOBuffer));
    //            //                runFFT = 1;
    //            //                fftBufIndex = 0;
    //            //            }
    //        }
    //        else
    //            fftBufIndex = 0;
    //        //        if (sample_count < 10)
    //        //            sample_count++;
    //        //        else
    //        //            sample_count = 0;
    //    }

    // Acknowledge this interrupt to receive more interrupts from group 6
    //
    //    index_tst++;
    //    if(index_tst>7)
    //    {
    //        index_tst = 0;
    //        //        GPIO_writePin(14,0);GPIO_ADS_SYNC
    //        //        NOP;
    //        //        GPIO_writePin(14,1);GPIO_ADS_SYNC
    //    }

    PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;
}





void _init_phase(phase_t * phase, phase_desc_t desc, analog_input_t * voltge_input, analog_input_t * current_input  )
{
    phase->desc = desc;

    // Initialize phase config and measures
    phase->config.kh = 1.0f; // Default kh value

    phase->config.v_factor_num = 1.0;
    phase->config.v_factor_den = 1.0;
    phase->config.i_factor_num = 1.0;
    phase->config.i_factor_den = 1.0;
    phase->config.flag_change_factor = false;

    phase->voltage_input = voltge_input;
    phase->current_input = current_input;

    phase->measures = (typeof(phase->measures)){
        .va = 0.0f,
                .w = 0.0f,
                .var = 0.0f,
                .wh = 0,
                .varh = 0.0f,
                .vah = 0.0f,
                .phi = 0.0f
    };
}


void _cla1_init(void)
{

    //
    // Suppressing #770-D conversion from pointer to smaller integer
    // The CLA address range is 16 bits so the addresses passed to the MVECT
    // registers will be in the lower 64KW address space. Turn the warning
    // back on after the MVECTs are assigned addresses
    //
#pragma diag_suppress=770

#ifdef CPU1
    EALLOW;
    CPU1_CLA1(ENABLE); // Enable CPU1.CLA module
    CPU2_CLA1(ENABLE); // Enable CPU2.CLA module

    CONNECT_SD1(TO_CPU1); // Connect SDFM1 to CPU1
    // CONNECT_SD2(TO_CPU1);       //Connect SDFM2 to CPU1
    VBUS32_1(CONNECT_TO_CLA1); // Connect VBUS32_1 (SDFM bus) to CPU1
    EDIS;
#endif

    // Configure the CLA memory spaces
    _cla1_memory_config();

#ifdef CPU1
    // Configure the CLA task vectors for CPU1
    _cla1_interruption_config();
#endif
#ifdef CPU2
    // Configure the CLA task vectors for CPU2
    CLA_initCpu2Cla();
#endif

}

// CLA_initCpu1Cla - Initialize CLA tasks and end of task ISRs
void _cla1_interruption_config(void)
{
    EALLOW;

    // Compute all CLA task vectors
    // On Type-1 CLAs the MVECT registers accept full 16-bit task addresses as
    // opposed to offsets used on older Type-0 CLAs
    //
    // Adding a pragma to suppress the warnings when casting the CLA tasks'
    // function pointers to uint16_t. Compiler believes this to be improper
    // although the CLA only has 16-bit addressing.
#pragma diag_suppress = 770

    //
    // Compute all CLA task vectors
    // On Type-2 CLAs the MVECT registers accept full 16-bit task addresses as
    // opposed to offsets used on older Type-0 CLAs
    //
    // Assign the task vectors
    //
    CLA_mapTaskVector(CLA1_BASE, CLA_MVECT_1, (uint16_t)&Cla1Task1);
    CLA_mapTaskVector(CLA1_BASE, CLA_MVECT_2, (uint16_t)&Cla1Task2);
    CLA_mapTaskVector(CLA1_BASE, CLA_MVECT_3, (uint16_t)&Cla1Task3);
    CLA_mapTaskVector(CLA1_BASE, CLA_MVECT_4, (uint16_t)&Cla1Task4);
    CLA_mapTaskVector(CLA1_BASE, CLA_MVECT_5, (uint16_t)&Cla1Task5);
    CLA_mapTaskVector(CLA1_BASE, CLA_MVECT_6, (uint16_t)&Cla1Task6);
    CLA_mapTaskVector(CLA1_BASE, CLA_MVECT_7, (uint16_t)&Cla1Task7);
    CLA_mapTaskVector(CLA1_BASE, CLA_MVECT_8, (uint16_t)&Cla1Task8);
#pragma diag_warning=770

    // Enable the IACK instruction to start a task on CLA in software
    // for all  8 CLA tasks. Also, globally enable all 8 tasks (or a
    // subset of tasks) by writing to their respective bits in the
    // MIER register
    __asm("   RPT #3 || NOP");
    CLA_enableIACK(CLA1_BASE);
    CLA_enableTasks(CLA1_BASE, CLA_TASKFLAG_ALL);

    //
    // Configure the vectors for the end-of-task interrupt for all
    // 8 tasks
    Interrupt_register(INT_CLA1_1, cla1Isr1);
    Interrupt_register(INT_CLA1_2, cla1Isr2);
    Interrupt_register(INT_CLA1_3, cla1Isr3);
    Interrupt_register(INT_CLA1_4, cla1Isr4);
    Interrupt_register(INT_CLA1_5, cla1Isr5);
    Interrupt_register(INT_CLA1_6, cla1Isr6);
    Interrupt_register(INT_CLA1_7, cla1Isr7);
    Interrupt_register(INT_CLA1_8, cla1Isr8);

    // Enable CLA interrupts at the group and subgroup levels
    Interrupt_enable(INT_CLA1_1);
    Interrupt_enable(INT_CLA1_2);
    Interrupt_enable(INT_CLA1_3);
    Interrupt_enable(INT_CLA1_4);
    Interrupt_enable(INT_CLA1_5);
    Interrupt_enable(INT_CLA1_6);
    Interrupt_enable(INT_CLA1_7);
    Interrupt_enable(INT_CLA1_8);
    IER |= INTERRUPT_CPU_INT11;


}

// Cla_initMemoryMap - Initialize CLA memory map
//
void _cla1_memory_config(void)
{



    // Give CLA control over program and data RAM(s)
    //     - The MemCfgRegs register is described in TRM 2.14.17
    //  Configure LS0RAM and LS1RAM as program spaces for the CLA
    //  First configure the CLA to be the master for LS5 and then
    //  set the spaces to be program blocks

    EALLOW;
    //
    // Initialize and wait for CLA1ToCPUMsgRAM
    //
    MemCfgRegs.MSGxINIT.bit.INIT_CLA1TOCPU = 1;
    while (MemCfgRegs.MSGxINITDONE.bit.INITDONE_CLA1TOCPU != 1)
    {
    };

    //
    // Initialize and wait for CPUToCLA1MsgRAM
    //
    MemCfgRegs.MSGxINIT.bit.INIT_CPUTOCLA1 = 1;
    while (MemCfgRegs.MSGxINITDONE.bit.INITDONE_CPUTOCLA1 != 1)
    {
    };

    //
    // Select LS0 LS1 RAM to be the programming space for the CLA
    //
    MemCfgRegs.LSxMSEL.bit.MSEL_LS0 = 1;
    MemCfgRegs.LSxCLAPGM.bit.CLAPGM_LS0 = 1;
    MemCfgRegs.LSxMSEL.bit.MSEL_LS1 = 1;
    MemCfgRegs.LSxCLAPGM.bit.CLAPGM_LS1 = 1;
    MemCfgRegs.LSxMSEL.bit.MSEL_LS2 = 1;
    MemCfgRegs.LSxCLAPGM.bit.CLAPGM_LS2 = 1;

    //
    // Select LS5 to be data RAM for the CLA
    //
    MemCfgRegs.LSxMSEL.bit.MSEL_LS3 = 1;     // LS3RAM is shared between CPU and CLA
    MemCfgRegs.LSxCLAPGM.bit.CLAPGM_LS3 = 0; // LS3RAM setup as data memory
    MemCfgRegs.LSxMSEL.bit.MSEL_LS4 = 1;     // LS2RAM is shared between CPU and CLA
    MemCfgRegs.LSxCLAPGM.bit.CLAPGM_LS4 = 0; // LS2RAM setup as data memory
    MemCfgRegs.LSxMSEL.bit.MSEL_LS5 = 1;     // LS3RAM is shared between CPU and CLA
    MemCfgRegs.LSxCLAPGM.bit.CLAPGM_LS5 = 0; // LS3RAM setup as data memory

    // Detect any CLA fetch access violations, enable
    // interrupt for it (TRM SPRUHM8, 2.11.1.7.4 & 2.14.18)
    AccessProtectionRegs.NMAVSET.bit.CLA1FETCH = 1;
    AccessProtectionRegs.NMAVINTEN.bit.CLA1FETCH = 1;
    // Set the ISR for access violation fault
    PieVectTable.RAM_ACCESS_VIOLATION_INT = access_violation;
    PieCtrlRegs.PIEIER12.bit.INTx12 = 1;
    IER |= M_INT12;

    EDIS;
}





#pragma CODE_SECTION(access_violation, "ramfuncs")
__interrupt void access_violation(void)
{
    // Read the fetch address where the violation occurred
    fetchAddress = AccessProtectionRegs.NMCLA1FAVADDR;

    EALLOW;
    // clear the fault
    AccessProtectionRegs.NMAVCLR.bit.CLA1FETCH = 1;
    EDIS;
    //__asm(" ESTOP0");
    // Acknowledge the RAM access violation interrupt
    PieCtrlRegs.PIEACK.all = M_INT12;
}

//
// cla1Isr1 - CLA 1 ISR 1
//
interrupt void cla1Isr1()
{

    led_zc_isr();
    Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP11);
}

//
// cla1Isr2 - CLA 1 ISR 2
//
interrupt void cla1Isr2()
{
    Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP11);
}

//
// cla1Isr3 - CLA 1 ISR 3
//
interrupt void cla1Isr3()
{
    Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP11);
}

//
// cla1Isr4 - CLA 1 ISR 4
//
interrupt void cla1Isr4()
{
    //    asm(" ESTOP0");
    Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP11);
}

//
// cla1Isr5 - CLA 1 ISR 5
//
interrupt void cla1Isr5()
{
    //    asm(" ESTOP0");
    Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP11);
}

//
// cla1Isr6 - CLA 1 ISR 6
//
interrupt void cla1Isr6()
{
    //    asm(" ESTOP0");
    Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP11);
}

//
// cla1Isr7 - CLA 1 ISR 7
//
interrupt void cla1Isr7()
{
    //    asm(" ESTOP0");
    Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP11);
}

//
// cla1Isr8 - CLA 1 ISR 8
//
interrupt void cla1Isr8()
{
    //    asm(" ESTOP0");
    Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP11);
}

float32_t volt = (127.0*1.4142) ;
float32_t curr = (1.0*1.4142);
int indexv = 0, indexi = 0, phi = 0;

#pragma CODE_SECTION(_measures_fill_data, "ramfuncs");
void _measures_fill_data(void)
{


    app.meter.phase[0].measures.v = cla_phase_aux.v_rms;
    app.meter.phase[0].measures.i = cla_phase_aux.i_rms;
    app.meter.phase[0].measures.phi = cla_phase_aux.phi;
    app.meter.phase[0].measures.power_factor = cla_phase_aux.power_factor;
    app.meter.phase[0].measures.wh = cla_phase_aux.energy.wh;
    app.meter.phase[0].measures.vah = cla_phase_aux.energy.vah;
    app.meter.phase[0].measures.varh = cla_phase_aux.energy.varh;
    app.meter.phase[0].measures.w = cla_phase_aux.w_cycle;
    app.meter.phase[0].measures.va = cla_phase_aux.va_cycle;
    app.meter.phase[0].measures.var = cla_phase_aux.var_cycle;
    app.meter.phase[0].measures.freq = cla_phase_aux.frequency;
    app.meter.phase[0].measures.period = cla_phase_aux.period;

    app.meter.phase[1].measures.v = cla_phase_a.v_rms;
    app.meter.phase[1].measures.i = cla_phase_a.i_rms;
    app.meter.phase[1].measures.phi = cla_phase_a.phi;
    app.meter.phase[1].measures.power_factor = cla_phase_a.power_factor;
    app.meter.phase[1].measures.wh = cla_phase_a.energy.wh;
    app.meter.phase[1].measures.vah = cla_phase_a.energy.vah;
    app.meter.phase[1].measures.varh = cla_phase_a.energy.varh;
    app.meter.phase[1].measures.w = cla_phase_a.w_cycle;
    app.meter.phase[1].measures.va = cla_phase_a.va_cycle;
    app.meter.phase[1].measures.var = cla_phase_a.var_cycle;
    app.meter.phase[1].measures.freq = cla_phase_a.frequency;
    app.meter.phase[1].measures.period = cla_phase_a.period;

    app.meter.phase[2].measures.v = cla_phase_b.v_rms;
    app.meter.phase[2].measures.i = cla_phase_b.i_rms;
    app.meter.phase[2].measures.phi = cla_phase_b.phi;
    app.meter.phase[2].measures.power_factor = cla_phase_b.power_factor;
    app.meter.phase[2].measures.wh = cla_phase_b.energy.wh;
    app.meter.phase[2].measures.vah = cla_phase_b.energy.vah;
    app.meter.phase[2].measures.varh = cla_phase_b.energy.varh;
    app.meter.phase[2].measures.w = cla_phase_b.w_cycle;
    app.meter.phase[2].measures.va = cla_phase_b.va_cycle;
    app.meter.phase[2].measures.var = cla_phase_b.var_cycle;
    app.meter.phase[2].measures.freq = cla_phase_b.frequency;
    app.meter.phase[2].measures.period = cla_phase_b.period;


    app.meter.phase[3].measures.v = cla_phase_c.v_rms;
    app.meter.phase[3].measures.i = cla_phase_c.i_rms;
    app.meter.phase[3].measures.phi = cla_phase_c.phi;
    app.meter.phase[3].measures.power_factor = cla_phase_c.power_factor;
    app.meter.phase[3].measures.wh = cla_phase_c.energy.wh;
    app.meter.phase[3].measures.vah = cla_phase_c.energy.vah;
    app.meter.phase[3].measures.varh = cla_phase_c.energy.varh;
    app.meter.phase[3].measures.w = cla_phase_c.w_cycle;
    app.meter.phase[3].measures.va = cla_phase_c.va_cycle;
    app.meter.phase[3].measures.var = cla_phase_c.var_cycle;
    app.meter.phase[3].measures.freq = cla_phase_c.frequency;
    app.meter.phase[3].measures.period = cla_phase_c.period;

}





void ledtest_begin(const ledtest_cfg_t *cfg)
{

    //memset(&cla_pulsing_led.test, 0, sizeof(cla_pulsing_led.test));
    meter_test.pulse_count = 0;
    meter_test.ref_energy_uWh = 0;


    meter_test.led_energy_comp_uWh = (uint32_t)(1000000000 / cfg->kh_imp_per_kwh); // 1e9/kH
    meter_test.target_pulses = cfg->target_pulses;
    meter_test.max_test_ms = cfg->max_test_ms;
    meter_test.armed_after_first_pulse = cfg->start_on_first_pulse ? 0 : 1;
    meter_test.energy_test_end_uwh = 0;
    meter_test.energy_test_init_uwh = 0;
    meter_test.frac_first_uWh = 0;
    meter_test.frac_last_uWh = 0;
    meter_test.sample_index_old = 0;
    meter_test.sample_index_new = 0;
    meter_test.state = meter_test.armed_after_first_pulse ? LEDTEST_ARMED : LEDTEST_RUNNING;
    //cla_pulsing_led.test.start_ts_us = my_time(NULL);


}

static inline int64_t snapshot_cycle_energy_uwh_stable(void)
{
    volatile int64_t uwha1, uwha2;
    volatile int64_t uwhb1, uwhb2;
    volatile int64_t uwhc1, uwhc2;
    do {
        uwha1 = (int64_t)cla_test_aux.energy_cycle_uwh_a;
        uwha2 = (int64_t)cla_test_aux.energy_cycle_uwh_a;
    } while (uwha1 != uwha2);
    do {
        uwhb1 = (int64_t)cla_test_aux.energy_cycle_uwh_b;
        uwhb2 = (int64_t)cla_test_aux.energy_cycle_uwh_b;
    } while (uwha1 != uwha2);
    do {
        uwhc1 = (int64_t)cla_test_aux.energy_cycle_uwh_c;
        uwhc2 = (int64_t)cla_test_aux.energy_cycle_uwh_c;
    } while (uwha1 != uwha2);
    return uwha1 + uwhb1 + uwhc1;
}


static inline int64_t snapshot_energy_uwh_stable(void)
{
    volatile int64_t uwha1, uwha2;
    volatile int64_t uwhb1, uwhb2;
    volatile int64_t uwhc1, uwhc2;

    do {
        uwha1 = (int64_t)cla_test_aux.energy_acc_wh_a * 1000000ULL+ (int64_t)cla_test_aux.energy_acc_uwh_a;
        uwha2 = (int64_t)cla_test_aux.energy_acc_wh_a * 1000000ULL+ (int64_t)cla_test_aux.energy_acc_uwh_a;
    } while (uwha1 != uwha2);
    do {
        uwhb1 = (int64_t)cla_test_aux.energy_acc_wh_b * 1000000ULL+ (int64_t)cla_test_aux.energy_acc_uwh_b;
        uwhb2 = (int64_t)cla_test_aux.energy_acc_wh_b * 1000000ULL+ (int64_t)cla_test_aux.energy_acc_uwh_b;
    } while (uwha1 != uwha2);
    do {
        uwhc1 = (int64_t)cla_test_aux.energy_acc_wh_c * 1000000ULL+ (int64_t)cla_test_aux.energy_acc_uwh_c;
        uwhc2 = (int64_t)cla_test_aux.energy_acc_wh_c * 1000000ULL+ (int64_t)cla_test_aux.energy_acc_uwh_c;
    } while (uwha1 != uwha2);
    return uwha1 + uwhb1 + uwhc1;
}





static inline float32_t snapshot_energy_dnwh_stable(void)
{
    volatile float32_t dnwha1, dnwha2;
    volatile float32_t dnwhb1, dnwhb2;
    volatile float32_t dnwhc1, dnwhc2;

        do {
            dnwha1 =  cla_test_aux.energy_dnwh_a[meter_test.sample_index_new];
            dnwha2 =  cla_test_aux.energy_dnwh_a[meter_test.sample_index_new];
        } while (dnwha1 != dnwha2);
        do {
            dnwhb1 =  cla_test_aux.energy_dnwh_b[meter_test.sample_index_new];
            dnwhb2 =  cla_test_aux.energy_dnwh_b[meter_test.sample_index_new];
        } while (dnwhb1 != dnwhb2);
        do {
            dnwhc1 =  cla_test_aux.energy_dnwh_c[meter_test.sample_index_new];
            dnwhc2 =  cla_test_aux.energy_dnwh_c[meter_test.sample_index_new];
        } while (dnwhc1 != dnwhc2);

    return (float32_t) dnwha1 + dnwhb1 + dnwhc1;
}





//float32_t mark[100];
//float32_t error[100];
//float32_t energy[100];
//float32_t energy1[100];
//float32_t frac1[100];
//float32_t frac2[100];
//float32_t energia1[100];
//float32_t energia2[100];
//float32_t ticks[100];
//
//
//float32_t index[100];
//float32_t index1[100];
//float32_t numciclos[100];
//int num_ciclo=0;
//
float32_t measurede_energy;
//
//int k=0;
//int j=0;





void led_pulse_isr(void)
{
    //uint8_t song = 4; // event_led_beep
    //ipc_buzzer_play( &song );

    if (meter_test.state == LEDTEST_DONE)
    {
        return;
    }
    else if (meter_test.state == LEDTEST_ARMED)
    {
        meter_test.state = LEDTEST_RUNNING;
    }
    else if (meter_test.state == LEDTEST_RUNNING)
    {
        meter_test.cycle_pulse_index = ( cycle_desc.wr_idx - (cycle_desc.last_end + 1) ) & RING_MASK;
        meter_test.test_ticks = zpt_get_elapsed_ticks();


        if(meter_test.pulse_count == 0)
        {
            meter_test.ref_energy_uWh = 0;
            meter_test.flag_first_pulse = true;

        }
        else if (meter_test.pulse_count >= meter_test.target_pulses)
        {
            meter_test.flag_last_pulse = true;
            meter_test.ref_energy_uWh += meter_test.led_energy_comp_uWh;


//            error[k] = meter_test.error_pct;
//            energy[k] = (float32_t)meter_test.energy_test_init_uwh;
//            energy1[k] = (float32_t)meter_test.energy_test_end_uwh;
//            frac1[k] = meter_test.frac_first_uWh;
//            frac2[k] = meter_test.frac_last_uWh;
//            energia1[k] = measurede_energy;
//            energia2[k] = (float)cla_phase_a.energy.uwh_acc;
//            ticks[k] = (float)meter_test.test_ticks;
//            index[k] = (float)meter_test.sample_index_old;
//            index1[k] = (float)meter_test.sample_index_new;
//            numciclos[k] = (float) num_ciclo;
//            k++;
//            if(k>=100)
//                k=0;



        }
        else{
            meter_test.ref_energy_uWh += meter_test.led_energy_comp_uWh;
        }

        meter_test.pulse_count++;
    }




}





void led_zc_isr(void)
{
    int64_t base_uwh = 0;
    int64_t cycle_uwh = 0;

//    mark[k] = 0;
    measurede_energy = 0;
//    num_ciclo++;

    if (meter_test.state != LEDTEST_RUNNING)
    {
        return;
    }



    if (meter_test.flag_first_zc)
    {
//        num_ciclo= 0;
//        mark[k] = 111;
        meter_test.sample_index_old = (meter_test.test_ticks * 512) / meter_test.cycle_ticks;
        if (meter_test.sample_index_old >= 512) meter_test.sample_index_old = 511;
        if (meter_test.sample_index_old < 0) meter_test.sample_index_old = 0;

        meter_test.sample_index_new = (meter_test.cycle_pulse_index * 512) / meter_test.cycle_samples;
        if (meter_test.sample_index_new >= 512) meter_test.sample_index_new = 511;
        if (meter_test.sample_index_new < 0) meter_test.sample_index_new = 0;

        base_uwh = snapshot_energy_uwh_stable();
        cycle_uwh = snapshot_cycle_energy_uwh_stable();


        meter_test.frac_first_uWh = cycle_uwh -  (snapshot_energy_dnwh_stable() / 1000.0);

        meter_test.energy_test_init_uwh = base_uwh;// - meter_test.frac_first_uWh;
        meter_test.flag_first_zc = false;

        measurede_energy = 0;

    }
    else if (meter_test.flag_last_zc)
    {
        //mark[k] = 222;
        meter_test.sample_index_old = (meter_test.test_ticks * 512) / meter_test.cycle_ticks;
        if (meter_test.sample_index_old >= 512) meter_test.sample_index_old = 511;
        if (meter_test.sample_index_old < 0) meter_test.sample_index_old = 0;

        meter_test.sample_index_new = (meter_test.cycle_pulse_index * 512) / meter_test.cycle_samples;
        if (meter_test.sample_index_new >= 512) meter_test.sample_index_new = 511;
        if (meter_test.sample_index_new < 0) meter_test.sample_index_new = 0;

        base_uwh = snapshot_energy_uwh_stable();
        cycle_uwh = snapshot_cycle_energy_uwh_stable();
        meter_test.frac_last_uWh = cycle_uwh - snapshot_energy_dnwh_stable() / 1000.0;

        meter_test.energy_test_end_uwh = base_uwh;// - meter_test.frac_last_uWh;

        // calcula erro e fecha
        if (meter_test.ref_energy_uWh > 0) {
            measurede_energy = ((float)meter_test.energy_test_end_uwh - (float)meter_test.energy_test_init_uwh) + meter_test.frac_first_uWh - meter_test.frac_last_uWh;
            meter_test.error_pct = 100.0f *
                    ((measurede_energy)  - (float)meter_test.ref_energy_uWh) /
                    (float)meter_test.ref_energy_uWh;
        } else {
            meter_test.error_pct = 0.0f;
        }
        meter_test.flag_last_zc = false;
        meter_test.state = LEDTEST_DONE;
    }


    //    error[k] = meter_test.error_pct;
    //    energy[k] = (float32_t)meter_test.energy_test_init_uwh;
    //    energy1[k] = (float32_t)meter_test.energy_test_end_uwh;
    //    frac1[k] = meter_test.frac_first_uWh;
    //    frac2[k] = meter_test.frac_last_uWh;
    //    energia1[k] = measurede_energy;
    //    energia2[k] = (float)cla_phase_a.energy.uwh_acc;
    //    ticks[k] = (float)meter_test.test_ticks;
    //    index[k] = (float)meter_test.sample_index_old;
    //    index1[k] = (float)meter_test.sample_index_new;
    //    numciclos[k] = (float) num_ciclo;
    //    k++;
    //    if(k>=100)
    //        k=0;

}




__interrupt void dmaADSchannels(void)
{

    int32_t voltage_a, voltage_b, voltage_c, voltage_n;
    int32_t current_a, current_b, current_c, current_n;
    float32_t fvoltage_a, fvoltage_b, fvoltage_c, fvoltage_n;
    float32_t fcurrent_a, fcurrent_b, fcurrent_c, fcurrent_n;

    GPIO_writePin(GPIO_DEBUG_0,1);

    // current samples delayed by delay_amount
    current_n = (long)ADS_values_DMA[0];
    voltage_n = (long)ADS_values_DMA[1];

    current_a = (long)ADS_values_DMA[6];
    voltage_a = (long)ADS_values_DMA[7];

    current_b = (long)ADS_values_DMA[4];
    voltage_b = (long)ADS_values_DMA[5];

    current_c = (long)ADS_values_DMA[2];
    voltage_c = (long)ADS_values_DMA[3];

    voltage_a -= voltage_n;
    voltage_b -= voltage_n;
    voltage_c -= voltage_n;

    fvoltage_a = voltage_a * VOLTAGE_RELATION;
    fvoltage_b = voltage_b * VOLTAGE_RELATION;
    fvoltage_c = voltage_c * VOLTAGE_RELATION;
    fvoltage_n = voltage_n * VOLTAGE_RELATION;

    fcurrent_a = current_a * CURRENT_RELATION;
    fcurrent_b = current_b * CURRENT_RELATION;
    fcurrent_c = current_c * CURRENT_RELATION;
    fcurrent_n = current_n * CURRENT_RELATION;


    /////test code: fake data////////////////////////////////////////////////
    //                {
    //                    fvoltage_a = volt * sinus651[indexv];
    //                    fvoltage_b = volt * sinus651[indexv];
    //                    fvoltage_c = volt * sinus651[indexv];
    //                    fcurrent_n = 0.0;
    //                    current_n = 0.0;
    //
    //                    if (indexv >= 651)
    //                        indexv = 0;
    //                    indexi = (indexv + phi + 651) % 651;
    //                    indexv++;
    //
    //                    fcurrent_a = curr * sinus651[indexi];
    //                    fcurrent_b = curr * sinus651[indexi];
    //                    fcurrent_c = curr * sinus651[indexi];
    //
    //                }
    //////////////////////////////////////////////////////////////////////

    uint32_t i = cycle_desc.wr_idx & RING_MASK;   // posição física
    ring_vn[i] = fvoltage_n;
    ring_in[i] = fcurrent_n;
    ring_va[i] = fvoltage_a;
    ring_ia[i] = fcurrent_a;
    ring_vb[i] = fvoltage_b;
    ring_ib[i] = fcurrent_b;
    ring_vc[i] = fvoltage_c;
    ring_ic[i] = fcurrent_c;
    cycle_desc.wr_idx++;                          // avança 1 amostra (em todas as séries)


    if (zc_process_sample(&zcA, fvoltage_a, &cla_phase_a.frequency, &cla_phase_a.period))
    {

        cla_phase_b.frequency=cla_phase_a.frequency;
        cla_phase_c.frequency=cla_phase_a.frequency;

        cla_phase_b.period=cla_phase_a.period;
        cla_phase_c.period=cla_phase_a.period;

        if( cla_phase_a.frequency > 20.0 && cla_phase_a.frequency < 80.0)
        {

            uint32_t end   = cycle_desc.wr_idx;                  // 1-past-last
            uint32_t count = end - cycle_desc.last_end;          // pode ser 40–1000
            if (count > NMAX_PER_CYCLE) count = NMAX_PER_CYCLE; // sanitizacao (opcional)

            cycle_desc.start = end - count;           // índice global do início
            cycle_desc.count = (uint16_t)count;

            cycle_desc.last_end = end;

            //led_pwm_set_from_grid_freq(cla_phase_a.frequency);
            //led_pwm_set_frequency_fast(f);



            if( meter_test.flag_first_pulse )
            {
                meter_test.cycle_samples =  cycle_desc.count;

                meter_test.flag_testing = true;
                meter_test.flag_first_zc = true;
                meter_test.flag_first_pulse = false;
            }
            if( meter_test.flag_last_pulse )
            {
                meter_test.cycle_samples =  cycle_desc.count;

                meter_test.flag_testing = false;
                meter_test.flag_last_zc = true;
                meter_test.flag_last_pulse = false;
            }


            _measures_fill_data();

            meter_test.period = zpt_get_elapsed_seconds();
            meter_test.frequency = 1.0/meter_test.period;
            meter_test.cycle_ticks = zpt_get_elapsed_ticks();
            zpt_reset_in_isr();

            flag_zc = true;


        }

    }


    //    if (zc_process_sample(&zcB, fvoltage_b, &cla_phase_b.frequency, &cla_phase_b.period))
    //    {
    //        GPIO_writePin(GPIO_DEBUG_0,1);
    //        GPIO_writePin(GPIO_DEBUG_0,0);
    //    }
    //
    //    if (zc_process_sample(&zcC, fvoltage_c, &cla_phase_c.frequency, &cla_phase_c.period))
    //    {
    //        GPIO_writePin(GPIO_DEBUG_0,1);
    //        GPIO_writePin(GPIO_DEBUG_0,0);
    //    }
    GPIO_writePin(GPIO_DEBUG_0,0);
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP7; // Clear interrupt flag

}

__interrupt void led_energy_toggle_isr(void)
{

    EPWM_clearEventTriggerInterruptFlag(EPWM_LED_BASE);
    Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP3);
}



//
// cpu_timer0_isr - CPU Timer0 ISR with interrupt counter
//
__interrupt void cpu_timer0_isr_main(void)
{
    // GPIO_WritePin(GPIO_PROFILING0, 1);
    CpuTimer0.InterruptCount++;

    //
    // Acknowledge this interrupt to receive more interrupts from group 1
    //
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
    // GPIO_WritePin(GPIO_PROFILING0, 0);
}

//
// cpu_timer1_isr - CPU Timer1 ISR
//
__interrupt void cpu_timer1_isr_main(void)
{
    // GPIO_WritePin(GPIO_PROFILING0, 1);
    CpuTimer1.InterruptCount++;
    // GPIO_WritePin(GPIO_PROFILING0, 0);
}

//
// cpu_timer2_isr CPU Timer2 ISR
//
__interrupt void cpu_timer2_isr_main(void)
{
    // GPIO_WritePin(GPIO_PROFILING0, 1);
    CpuTimer2.InterruptCount++;
    // GPIO_WritePin(GPIO_PROFILING0, 0);
}

//
// xint1_isr - External Interrupt 1 ISR
//

uint32_t g_debounce_us = 100;//100ms

interrupt void xint1_isr(void)
{
    led_pulse_isr();
    GPIO_writePin(EPWM_LED_GPIO,1);


    //
    //    int i;
    //    buzzer_set_event(&app.buzzer, BUZZER_COMMUNICATION);
    //    // GPIO_togglePin(DEVICE_GPIO_PIN_LED2);
    //
    //    if (cla_test.flag_testing == true)
    //    {
    //        cla_test.pulses_generated++;
    //
    //        if (cla_test.pulses_generated >= cla_test.pulses_expected)
    //        {
    //            cla_test.flag_testing = false;
    //            cla_test.flag_end_test = true;
    //            cla_test.energy_measured = (float32_t)cla_test.energy_acc_wh + ((float32_t)cla_test.energy_acc_uwh/1e6);
    //        }
    //    }
    //
    //    if (cla_test.flag_start_test)
    //    {
    //        cla_test.flag_start_test = false;
    //        cla_test.flag_testing = true;
    //        cla_test.led_energy = 0.0f;
    //        cla_test.energy_measured = 0.0f;
    //        cla_test.energy_acc_uwh = 0;
    //        cla_test.energy_acc_wh = 0;
    //        cla_test.pulses_generated = 0;
    //
    //        //        for(i=0;i<4;i++){
    //        //            app.meter.phase[i].voltage.measures.avg = 0.0f;
    //        //            app.meter.phase[i].voltage.measures.max = 0.0f;
    //        //            app.meter.phase[i].voltage.measures.min = 0.0f;
    //        //            app.meter.phase[i].voltage.measures.rms = 0.0f;
    //        //            app.meter.phase[i].current.measures.avg = 0.0f;
    //        //            app.meter.phase[i].current.measures.max = 0.0f;
    //        //            app.meter.phase[i].current.measures.min = 0.0f;
    //        //            app.meter.phase[i].current.measures.rms = 0.0f;
    //        //            // Cla1ForceTask3();
    //        //            cla_phase[i].sine_analyzer.vMax = FLT_MIN;
    //        //            cla_phase[i].sine_analyzer.vMin = FLT_MAX;
    //        //            cla_phase[i].sine_analyzer.iMax = FLT_MIN;
    //        //            cla_phase[i].sine_analyzer.iMin = FLT_MAX;
    //        //            cla_phase[i].sine_analyzer.iAvgAcc = 0;
    //        //            cla_phase[i].sine_analyzer.vAvgAcc = 0;
    //        //            cla_phase[i].sine_analyzer.iSumAcc = 0;
    //        //            cla_phase[i].sine_analyzer.vSumAcc = 0;
    //        //            cla_phase[i].sine_analyzer.iCntAcc = 0;
    //        //            cla_phase[i].sine_analyzer.vCntAcc = 0;
    //        //            cla_phase[i].sine_analyzer.pfAvg = 0;
    //        //            cla_phase[i].sine_analyzer.pfMax = 0.0;
    //        //            cla_phase[i].sine_analyzer.pfMin = 1.0;
    //        //        }
    //    }
    //
    GPIO_writePin(EPWM_LED_GPIO,0);

    Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP1);

}
